{"file_contents":{"DEPLOYMENT.md":{"content":"# Deployment Guide - Seana Bot\n\n## Railway Deployment\n\n### Prerequisites\n1. Railway account (https://railway.app)\n2. MongoDB Atlas account atau database MongoDB\n3. Repository di GitHub/GitLab\n\n### Step-by-Step Railway Deployment\n\n#### 1. Persiapan Environment Variables\nSiapkan environment variables berikut di Railway:\n\n```bash\nNODE_ENV=production\nPORT=5000\nNODE_VERSION=20\nMONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/seanabot\n```\n\n**PENTING**: Pastikan menggunakan Node.js 20+ karena @whiskeysockets/baileys memerlukan Node.js 20+\n\n#### 2. Deploy via Railway Dashboard\n1. Login ke Railway dashboard\n2. Klik \"New Project\" ‚Üí \"Deploy from GitHub repo\"\n3. Pilih repository yang berisi Seana Bot\n4. Railway akan otomatis detect Dockerfile dan melakukan build\n\n#### 3. Deploy via Railway CLI\n```bash\n# Install Railway CLI\nnpm install -g @railway/cli\n\n# Login\nrailway login\n\n# Init project\nrailway init\n\n# Deploy\nrailway up\n```\n\n#### 4. Konfigurasi Domain (Opsional)\n1. Di Railway dashboard, pilih project\n2. Go to Settings ‚Üí Domains\n3. Generate domain atau tambahkan custom domain\n\n### Environment Variables Required\n\n| Variable | Description | Example |\n|----------|-------------|---------|\n| `NODE_ENV` | Environment mode | `production` |\n| `PORT` | Server port | `5000` |\n| `MONGODB_URI` | MongoDB connection string | `mongodb+srv://user:pass@cluster.mongodb.net/seanabot` |\n\n### Docker Deployment (Alternative)\n\n#### Build dan Run Manual\n```bash\n# Build image\ndocker build -t seana-bot .\n\n# Run container\ndocker run -p 5000:5000 \\\n  -e NODE_ENV=production \\\n  -e MONGODB_URI=your_mongodb_uri \\\n  seana-bot\n```\n\n#### Menggunakan Docker Compose\n```bash\n# Run dengan database MongoDB local\ndocker-compose up -d\n\n# Run tanpa MongoDB local (gunakan MongoDB Atlas)\ndocker-compose up -d seana-bot\n```\n\n### Production Checklist\n\n#### Sebelum Deploy\n- [ ] MongoDB Atlas cluster sudah setup dan running\n- [ ] Environment variables sudah dikonfigurasi\n- [ ] Firewall rules sudah diatur (jika perlu)\n\n#### Setelah Deploy\n- [ ] Health check endpoint `/api/bot-status` berfungsi\n- [ ] QR code dapat di-generate di web interface\n- [ ] Bot dapat connect ke WhatsApp\n- [ ] Database connection berfungsi\n- [ ] Logging berfungsi dengan baik\n\n### Monitoring & Maintenance\n\n#### Railway Dashboard\n- Monitor resource usage (CPU, Memory, Network)\n- Check deployment logs\n- Monitor health checks\n\n#### Bot Status Endpoints\n- Health check: `GET /api/bot-status`\n- QR code: `GET /api/qr-code`\n\n#### Troubleshooting Common Issues\n\n1. **Docker Build Error: Node.js Version**\n   ```\n   Error: This package requires Node.js 20+ to run reliably\n   ```\n   **Solution**: Pastikan menggunakan Node.js 20+ di Dockerfile dan set NODE_VERSION=20 di environment variables\n\n2. **npm ci --only=production deprecated warning**\n   ```\n   npm warn config only Use `--omit=dev` to omit dev dependencies\n   ```\n   **Solution**: Gunakan `npm ci --omit=dev` instead of `--only=production`\n\n3. **Bot tidak bisa connect ke WhatsApp**\n   - Check apakah QR code ter-generate\n   - Pastikan tidak ada instance bot lain yang running\n   - Restart service\n\n4. **Database connection failed**\n   - Verify MONGODB_URI environment variable\n   - Check database server status\n   - Verify network connectivity\n\n5. **Memory/CPU issues**\n   - Monitor resource usage di Railway dashboard\n   - Scale up instance jika perlu\n   - Check untuk memory leaks\n\n6. **Baileys Engine Requirements Error**\n   - Pastikan NODE_VERSION environment variable set ke \"20\"\n   - Rebuild dengan Dockerfile yang sudah diupdate\n   - Gunakan Dockerfile.multistage untuk optimized build\n\n### Scaling\n\n#### Horizontal Scaling\nRailway support auto-scaling berdasarkan traffic. Konfigurasi di:\n- Settings ‚Üí Autoscaling\n- Set minimum dan maximum replicas\n\n#### Vertical Scaling\nUpgrade plan Railway untuk resource lebih besar:\n- More RAM\n- More CPU\n- Better performance\n\n### Backup & Recovery\n\n#### WhatsApp Auth State\n- File auth_info_baileys/ akan disimpan dalam container\n- Untuk persistent storage, mount volume atau gunakan Railway volumes\n\n#### Database Backup\n- Setup automated backup di MongoDB Atlas\n- Atau manual backup berkala\n\n### Security Best Practices\n\n1. **Environment Variables**\n   - Jangan commit secrets ke repository\n   - Gunakan Railway environment variables\n\n2. **Network Security**\n   - Railway provides HTTPS by default\n   - Gunakan secure MongoDB connection (SSL)\n\n3. **Access Control**\n   - Implement rate limiting\n   - Monitor unauthorized access attempts\n\n### Cost Optimization\n\n1. **Railway Usage**\n   - Monitor usage di dashboard\n   - Setup billing alerts\n   - Scale down saat tidak diperlukan\n\n2. **Database Costs**\n   - Optimize MongoDB queries\n   - Setup proper indexing\n   - Monitor database size\n\n## Support\n\nJika ada masalah dengan deployment:\n1. Check Railway logs\n2. Verify environment variables\n3. Test health check endpoints\n4. Contact support jika diperlukan","size_bytes":4931},"deploy.sh":{"content":"#!/bin/bash\n\n# Seana Bot Deployment Script for Railway\n# This script helps deploy the bot to Railway platform\n\necho \"üöÄ Seana Bot Railway Deployment Script\"\necho \"========================================\"\n\n# Check if Railway CLI is installed\nif ! command -v railway &> /dev/null; then\n    echo \"‚ùå Railway CLI is not installed\"\n    echo \"üì• Installing Railway CLI...\"\n    npm install -g @railway/cli\nfi\n\n# Login to Railway (if not already logged in)\necho \"üîë Checking Railway authentication...\"\nif ! railway whoami &> /dev/null; then\n    echo \"üîê Please login to Railway...\"\n    railway login\nfi\n\n# Initialize Railway project (if not already initialized)\nif [ ! -f \"railway.toml\" ] && [ ! -f \".railway\" ]; then\n    echo \"üéØ Initializing Railway project...\"\n    railway init\nfi\n\n# Check environment variables\necho \"üîß Checking required environment variables...\"\n\nREQUIRED_VARS=(\"MONGODB_URI\" \"NODE_ENV\" \"PORT\")\nMISSING_VARS=()\n\nfor var in \"${REQUIRED_VARS[@]}\"; do\n    if ! railway variables get $var &> /dev/null; then\n        MISSING_VARS+=($var)\n    fi\ndone\n\nif [ ${#MISSING_VARS[@]} -ne 0 ]; then\n    echo \"‚ö†Ô∏è  Missing required environment variables:\"\n    for var in \"${MISSING_VARS[@]}\"; do\n        echo \"   - $var\"\n    done\n    echo \"\"\n    echo \"Please set them using:\"\n    echo \"railway variables set VARIABLE_NAME=value\"\n    echo \"\"\n    read -p \"Do you want to set them now? (y/n): \" -n 1 -r\n    echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n        for var in \"${MISSING_VARS[@]}\"; do\n            read -p \"Enter value for $var: \" value\n            railway variables set $var=\"$value\"\n        done\n    else\n        echo \"‚ùå Deployment cancelled. Please set required variables first.\"\n        exit 1\n    fi\nfi\n\n# Deploy to Railway\necho \"üöÄ Deploying to Railway...\"\nrailway up\n\n# Check deployment status\necho \"‚úÖ Deployment initiated!\"\necho \"\"\necho \"üîó You can check the deployment status at:\"\necho \"   https://railway.app/dashboard\"\necho \"\"\necho \"üì± Once deployed, you can access your bot at the Railway provided URL\"\necho \"üîß Monitor logs using: railway logs\"\necho \"\"\necho \"üéâ Deployment complete!\"","size_bytes":2129},"index.js":{"content":"const { default: makeWASocket, DisconnectReason, useMultiFileAuthState } = require('@whiskeysockets/baileys');\nconst qrcode = require('qrcode-terminal');\nconst { Boom } = require('@hapi/boom');\nconst config = require('./config/config');\nconst connectDB = require('./database/connection');\nconst commandHandler = require('./handlers/commandHandler');\nconst { createUser, getUser } = require('./utils/userUtils');\n\n// Import setBotInstance and setQRCode from server if running both\nlet setBotInstance, setQRCode;\ntry {\n    const serverModule = require('./server');\n    setBotInstance = serverModule.setBotInstance;\n    setQRCode = serverModule.setQRCode;\n} catch (error) {\n    // Server not loaded, that's okay\n    setBotInstance = null;\n    setQRCode = null;\n}\n\nclass SeanaBot {\n    constructor() {\n        this.sock = null;\n        this.isConnected = false;\n    }\n\n    async initialize() {\n        try {\n            console.log('üöÄ Starting Seana Bot...');\n            \n            // Connect to MongoDB\n            await connectDB();\n            \n            // Initialize WhatsApp connection\n            await this.connectWhatsApp();\n            \n        } catch (error) {\n            console.error('‚ùå Failed to initialize bot:', error.message);\n            process.exit(1);\n        }\n    }\n\n    async connectWhatsApp() {\n        try {\n            const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');\n            \n            this.sock = makeWASocket({\n                auth: state,\n                browser: ['Seana Bot', 'Chrome', '1.0.0']\n            });\n\n            // Handle connection updates\n            this.sock.ev.on('connection.update', async (update) => {\n                const { connection, lastDisconnect, qr } = update;\n                \n                if (qr) {\n                    console.log('üì± Scan QR Code to connect WhatsApp:');\n                    qrcode.generate(qr, { small: true });\n                    \n                    // Store QR code for web display\n                    if (setQRCode) {\n                        setQRCode(qr);\n                    }\n                }\n                \n                if (connection === 'close') {\n                    const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;\n                    console.log('‚ùå Connection closed due to:', lastDisconnect?.error);\n                    \n                    if (shouldReconnect) {\n                        console.log('üîÑ Reconnecting...');\n                        setTimeout(() => this.connectWhatsApp(), 3000);\n                    } else {\n                        console.log('‚ö†Ô∏è Logged out. Please restart the bot.');\n                        process.exit(0);\n                    }\n                } else if (connection === 'open') {\n                    console.log('‚úÖ WhatsApp connected successfully!');\n                    console.log(`ü§ñ Bot Name: ${config.botName}`);\n                    console.log(`üëë Owner: ${config.ownerNumber}`);\n                    this.isConnected = true;\n                    \n                    // Clear QR code when connected\n                    if (setQRCode) {\n                        setQRCode(null);\n                    }\n                    \n                    // Set bot instance for web server\n                    if (setBotInstance) {\n                        setBotInstance(this);\n                        console.log('üîó Bot instance connected to web server');\n                        console.log('üîç Bot instance details:', {\n                            isConnected: this.isConnected,\n                            hasSocket: !!this.sock,\n                            socketConnected: this.sock ? 'ready' : 'not ready'\n                        });\n                    }\n                    \n                    // Test message capability\n                    console.log('üß™ Bot ready to send messages');\n                }\n            });\n\n            // Handle credential updates\n            this.sock.ev.on('creds.update', saveCreds);\n\n            // Handle incoming messages\n            this.sock.ev.on('messages.upsert', async (messageUpdate) => {\n                const { messages } = messageUpdate;\n                \n                for (const message of messages) {\n                    if (message.key.fromMe || !message.message) continue;\n                    \n                    try {\n                        await this.handleMessage(message);\n                    } catch (error) {\n                        console.error('‚ùå Error handling message:', error.message);\n                    }\n                }\n            });\n\n        } catch (error) {\n            console.error('‚ùå WhatsApp connection error:', error.message);\n            setTimeout(() => this.connectWhatsApp(), 5000);\n        }\n    }\n\n    async handleMessage(message) {\n        const from = message.key.remoteJid;\n        const sender = message.key.participant || from;\n        \n        // Extract text from different message types including image captions\n        let messageText = '';\n        if (message.message?.conversation) {\n            messageText = message.message.conversation;\n        } else if (message.message?.extendedTextMessage?.text) {\n            messageText = message.message.extendedTextMessage.text;\n        } else if (message.message?.imageMessage?.caption) {\n            messageText = message.message.imageMessage.caption;\n        } else if (message.message?.videoMessage?.caption) {\n            messageText = message.message.videoMessage.caption;\n        } else if (message.message?.documentMessage?.caption) {\n            messageText = message.message.documentMessage.caption;\n        }\n\n        // Only process commands that start with '.'\n        if (!messageText.startsWith('.')) return;\n\n        const command = messageText.slice(1).split(' ')[0].toLowerCase();\n        const args = messageText.slice(1).split(' ').slice(1);\n\n        console.log(`üì® Command received: .${command} from ${sender}`);\n        console.log(`üìù Message pushName: ${message.pushName || 'not available'}`);\n        console.log(`üìù Message verifiedBizName: ${message.verifiedBizName || 'not available'}`);\n\n        // Ensure user exists in database\n        await createUser(sender, {}, this.sock);\n\n        // Handle the command\n        await commandHandler(this.sock, from, sender, command, args, message);\n    }\n\n    async sendMessage(jid, content) {\n        if (!this.isConnected) {\n            console.log('‚ö†Ô∏è Bot not connected yet');\n            return;\n        }\n        \n        try {\n            await this.sock.sendMessage(jid, { text: content });\n        } catch (error) {\n            console.error('‚ùå Failed to send message:', error.message);\n        }\n    }\n}\n\n// Initialize and start the bot\nconst bot = new SeanaBot();\nbot.initialize();\n\n// Also start the web server\nrequire('./server');\n\n// Handle process termination\nprocess.on('SIGINT', () => {\n    console.log('\\nüëã Shutting down Seana Bot...');\n    process.exit(0);\n});\n\nprocess.on('uncaughtException', (error) => {\n    console.error('‚ùå Uncaught Exception:', error.message);\n});\n\nprocess.on('unhandledRejection', (error) => {\n    console.error('‚ùå Unhandled Rejection:', error.message);\n});\n","size_bytes":7296},"railway.toml":{"content":"[build]\nbuilder = \"dockerfile\"\n\n[deploy]\nstartCommand = \"node index.js\"\nhealthcheckPath = \"/api/bot-status\"\nhealthcheckTimeout = 30\nrestartPolicyType = \"on_failure\"\nnumReplicas = 1\n\n[env]\nNODE_ENV = \"production\"\nPORT = \"5000\"\nNODE_VERSION = \"20\"","size_bytes":245},"replit.md":{"content":"# Seana Bot - WhatsApp Bot System\n\n## Overview\n\nSeana Bot is a WhatsApp bot built using Node.js that provides automated messaging services through the WhatsApp Web API via Baileys library. The bot features a command-based interface with user management, rate limiting, and MongoDB integration for persistent data storage. Bot is fully operational and ready for WhatsApp connection via QR code scanning.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## Recent Changes (July 28, 2025)\n\n‚úÖ **Project Migration and Rank System Update Completed Successfully**\n- Successfully migrated WhatsApp Bot project from Replit Agent to standard Replit environment\n- Fixed critical syntax error in server.js that was preventing startup\n- Resolved navigation dropdown menu layout issue - now displays as wide horizontal menu\n- Fixed profile page level display bug - level now updates properly from database changes\n- **Fixed rank system to update dynamically with level changes**\n- **Changed XP requirements from medium to easy difficulty (50% less XP needed)**\n- **Removed duplicate ranks from configuration and cleaned up rank system**\n- **Fixed totalXp display to show real data from database instead of placeholder values**\n- **Recalculated and corrected all users' totalXp values based on their current level**\n- **Added Edit Profile functionality with modal interface for updating username and profile photo**\n- **Created profile photo upload system with database integration and real-time preview**\n- **Fixed horizontal scrolling issue on profile page with responsive CSS design**\n- **Fixed \"updateUser is not defined\" error by adding missing import**\n- **Made username and profile photo fields optional - users can update either or both**\n- **Added mobile-responsive layout with proper breakpoints for tablets and phones**\n- All dependencies verified and properly installed with security vulnerabilities addressed  \n- WhatsApp Bot workflow running correctly with QR code generation\n- Web server functional on port 5000 with MongoDB connection established\n- User management system working correctly with real-time database updates\n\n## Previous Changes (July 27, 2025)\n\n‚úÖ **Migration to Replit Completed Successfully**\n- Migrated project from Replit Agent to standard Replit environment\n- Fixed integration between WhatsApp bot and web server components\n- Resolved QR code loading issue in web interface\n- Bot and web server now run simultaneously on single workflow\n- All features verified working: QR generation, web interface, bot commands\n\n‚úÖ **Complete Web Dashboard with Advanced Navigation System Built**\n- Created comprehensive navigation system with desktop (top nav + dropdown) and mobile (top + bottom nav + sheet) layouts\n- Implemented 4 main navigation menus: home, news, profile, list with extensive submenus\n- Built responsive navigation components: desktop dropdown, mobile bottom sheet, sticky positioning\n- Created complete page templates: home, news, profile, shop, redeem, member, quest, mine\n- Implemented proper user authentication flow and data integration across all pages\n- Added currency display, user status indicators, and owner-specific navigation items\n- Navigation system is modular and reusable across all dashboard pages\n\n‚úÖ **Railway Deployment Support Added**\n- Created comprehensive Docker configuration with multi-stage builds\n- Added Railway-specific configuration files (railway.json, railway.toml)\n- Implemented proper environment variable handling for production\n- Created deployment documentation and automation scripts\n- Added Docker Compose for local development with MongoDB\n\n‚úÖ **Bot Successfully Deployed and Running**\n- Fixed TypeScript syntax error in connection handler\n- Resolved MongoDB connection issues by removing deprecated options\n- Removed duplicate schema index warnings\n- WhatsApp connection established with QR code display\n- All commands (.menu, .ping, .profile, .s/.sticker) implemented and tested\n- Owner number configured: 6285709557572\n- Database connected to MongoDB Atlas cluster\n\n‚úÖ **Profile Command Enhanced**\n- Username now fetched from actual WhatsApp profile name using pushName\n- Removed limit deduction notification for cleaner UX\n- Profile command now sends user's profile picture with caption\n- Silent limit deduction without user notification\n- Improved error handling for profile data fetching\n\n‚úÖ **Sticker Feature Added**\n- Implemented .s/.sticker commands for image to sticker conversion\n- Support for reply to images (including view once images)\n- Support for images sent with command caption\n- Sticker pack: \"seana bot\", author: \"pioo\" as configured\n- Dependencies installed: sharp, wa-sticker-formatter for proper metadata\n- Comprehensive error handling and user feedback\n- Automatic image resizing to 512x512 WebP format\n- Fixed metadata implementation using wa-sticker-formatter library\n- Proper EXIF data embedding for WhatsApp sticker pack information\n- Sticker command now requires 1 limit to use\n\n‚úÖ **Bot System Updates**\n- Dynamic bot name in menu from config (SEANA BOT MENU)\n- Updated status system: owner/premium/basic (removed admin)\n- Unlimited limits for owner and premium users (‚àû unlimited)\n- Owner automatically gets owner status upon first interaction\n- Profile display shows \"‚àû (unlimited)\" for owner/premium users\n- Enhanced limit checking system with unlimited status support\n\n## System Architecture\n\n### Backend Architecture\n- **Runtime**: Node.js with JavaScript\n- **WhatsApp Integration**: @whiskeysockets/baileys library for WhatsApp Web API\n- **Database**: MongoDB with Mongoose ODM\n- **Architecture Pattern**: Modular command-based system with handlers\n\n### Key Design Decisions\n- **Modular Command System**: Each command is a separate module for easy maintenance and extensibility\n- **User Management**: Comprehensive user system with status levels, limits, and resource tracking\n- **Error Handling**: Centralized error handling with user-friendly messages\n- **Authentication**: WhatsApp Web authentication using multi-file auth state\n\n## Key Components\n\n### Core Components\n1. **Main Bot Class (SeanaBot)**: Central orchestrator handling WhatsApp connection and initialization\n2. **Command Handler**: Routes and executes user commands with permission checks\n3. **User Management**: Handles user creation, authentication, and resource management\n4. **Database Models**: Mongoose schemas for user data persistence\n\n### Command System\n- **Prefix-based Commands**: Uses '.' as command prefix\n- **Rate Limiting**: Commands can require \"limit\" consumption to prevent abuse\n- **Permission Levels**: Owner, admin, and basic user status levels\n- **Built-in Commands**: menu, ping, profile commands included\n\n### User System\n- **Auto-registration**: New users are automatically created on first interaction\n- **Resource Management**: Users have limits, balance, and chips for various bot features\n- **Status Hierarchy**: Owner > Admin > Basic user permissions\n- **Activity Tracking**: Last activity and membership duration tracking\n\n## Data Flow\n\n1. **Message Reception**: WhatsApp messages received through Baileys connection\n2. **Command Parsing**: Message text parsed for command prefix and arguments\n3. **User Authentication**: User retrieved/created from database with permission validation\n4. **Rate Limiting**: Command limit requirements checked against user resources\n5. **Command Execution**: Appropriate command handler invoked with validated parameters\n6. **Response Generation**: Bot sends formatted response back to WhatsApp\n7. **State Updates**: User limits and activity updated in database\n\n## External Dependencies\n\n### Core Dependencies\n- **@whiskeysockets/baileys**: WhatsApp Web API integration\n- **mongoose**: MongoDB object modeling\n- **qrcode-terminal**: QR code display for WhatsApp authentication\n- **@hapi/boom**: Error handling utilities\n\n### Database Schema\n- **Users Collection**: Stores user data including permissions, resources, and activity\n- **Authentication State**: File-based WhatsApp session persistence\n\n## Deployment Strategy\n\n### Multi-Platform Support\n- **Replit**: Native support with workflow configuration and port binding\n- **Railway**: Full Docker containerization with automated deployment\n- **Docker**: Standalone container deployment with health checks\n- **Local Development**: Docker Compose with optional MongoDB service\n\n### Environment Configuration\n- **MongoDB URI**: Configurable through environment variables with fallback\n- **Owner Number**: Hardcoded in config for initial setup\n- **Default Settings**: Centralized configuration for user defaults and bot behavior\n- **Production Variables**: Comprehensive .env.example template provided\n\n### Connection Management\n- **Auto-reconnection**: Handles WhatsApp disconnections with automatic retry\n- **Database Pooling**: MongoDB connection pooling for performance\n- **Error Recovery**: Graceful handling of database and WhatsApp connection errors\n- **Health Monitoring**: API endpoints for status checking and monitoring\n\n### Scalability Considerations\n- **Modular Commands**: Easy to add new commands without core changes\n- **Database Indexing**: User ID indexing for fast lookups\n- **Resource Limits**: Built-in rate limiting prevents abuse\n- **Session Persistence**: WhatsApp authentication state preserved across restarts\n\n### Security Features\n- **Permission System**: Multi-level user access control\n- **Rate Limiting**: Command usage limits prevent spam\n- **Input Validation**: Command parsing and argument validation\n- **Error Sanitization**: Safe error messages without exposing internals","size_bytes":9642},"server.js":{"content":"const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst QRCode = require('qrcode');\nconst multer = require('multer');\nconst config = require('./config/config');\nconst { getUser, createUser, updateUser } = require('./utils/userUtils');\nconst { \n    initAnnouncementsTable, \n    getRecentAnnouncements, \n    getAllAnnouncements,\n    addAnnouncement,\n    updateAnnouncement,\n    deleteAnnouncement\n} = require('./database/announcements');\n\nconst {\n    initPostsTable,\n    getRecentPosts,\n    getPostsByUser,\n    createPost,\n    updatePost,\n    deletePost,\n    likePost,\n    unlikePost,\n    addComment\n} = require('./database/posts');\n\nconst {\n    initBordersTable,\n    getAllBorders,\n    getBorderById,\n    createBorder,\n    updateBorder,\n    deleteBorder,\n    getUserBorders,\n    addBorderToUser,\n    equipBorder,\n    getUserEquippedBorder\n} = require('./database/borders');\n\nconst {\n    initShopTable,\n    getAllShopItems,\n    getShopItemById,\n    createShopItem,\n    updateShopItem,\n    deleteShopItem,\n    purchaseItem,\n    getUserPurchaseHistory\n} = require('./database/shop');\n\n// Global variable to store bot instance\nlet botInstance = null;\nlet currentQRCode = null;\n\n// Function to set bot instance from index.js\nconst setBotInstance = (bot) => {\n    botInstance = bot;\n};\n\n// Function to set current QR code\nconst setQRCode = (qrCode) => {\n    currentQRCode = qrCode;\n    console.log('üîÑ QR Code updated for web display');\n};\n\n// Function to send verification code via WhatsApp\nconst sendVerificationCode = async (phone, code) => {\n    console.log(`üîÑ Attempting to send verification code to ${phone}`);\n    console.log(`üîç Bot instance exists: ${!!botInstance}`);\n    console.log(`üîç Bot connected: ${botInstance ? botInstance.isConnected : 'N/A'}`);\n    console.log(`üîç Bot socket exists: ${botInstance && botInstance.sock ? 'YES' : 'NO'}`);\n\n    if (!botInstance || !botInstance.isConnected || !botInstance.sock) {\n        console.log('‚ö†Ô∏è Bot not properly connected, cannot send verification code');\n        console.log(`‚ö†Ô∏è Bot instance: ${!!botInstance}, isConnected: ${botInstance ? botInstance.isConnected : 'N/A'}, socket: ${botInstance && botInstance.sock ? 'exists' : 'missing'}`);\n        return false;\n    }\n\n    try {\n        const whatsappId = phone + '@s.whatsapp.net';\n        const message = `üîê *Kode Verifikasi NoMercy*\\n\\nKode verifikasi Anda: *${code}*\\n\\nMasukkan kode ini di website untuk login.\\nKode berlaku selama 5 menit.\\n\\n_Jangan bagikan kode ini kepada siapapun!_`;\n\n        console.log(`üì§ Sending message to ${whatsappId}`);\n        console.log(`üìù Message content: ${message}`);\n\n        // Use the socket directly to send message\n        await botInstance.sock.sendMessage(whatsappId, { text: message });\n        console.log(`‚úÖ Verification code successfully sent to ${phone}`);\n        return true;\n    } catch (error) {\n        console.error('‚ùå Failed to send verification code:', error);\n        console.error('‚ùå Error details:', {\n            message: error.message,\n            stack: error.stack,\n            name: error.name\n        });\n        return false;\n    }\n};\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\n// Middleware\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(session({\n    secret: 'seanabot-secret-key',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: false }\n}));\n\n// Set view engine\napp.set('view engine', 'ejs');\napp.set('views', path.join(__dirname, 'views'));\n\n// Store verification codes temporarily\nconst verificationCodes = new Map();\n\n// Multer configuration for file uploads\nconst storage = multer.diskStorage({\n    destination: function (req, file, cb) {\n        if (file.fieldname === 'borderImage') {\n            cb(null, 'public/borders/');\n        } else {\n            cb(null, 'public/uploads/');\n        }\n    },\n    filename: function (req, file, cb) {\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n        if (file.fieldname === 'borderImage') {\n            cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n        } else {\n            cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n        }\n    }\n});\n\nconst upload = multer({ \n    storage: storage,\n    fileFilter: function (req, file, cb) {\n        // Accept images only\n        if (!file.originalname.match(/\\.(jpg|jpeg|png|svg|webp)$/)) {\n            req.fileValidationError = 'Only image files are allowed!';\n            return cb(new Error('Only image files are allowed!'), false);\n        }\n        cb(null, true);\n    },\n    limits: {\n        fileSize: 5 * 1024 * 1024 // 5MB limit\n    }\n});\n\n// Routes\napp.get('/', (req, res) => {\n    if (req.session.isAuthenticated || req.session.isOwner) {\n        // If user is authenticated, redirect to home dashboard\n        return res.redirect('/home');\n    }\n    res.render('index');\n});\n\n// Test route for dashboard-owner (temporary)\napp.get('/test-dashboard', (req, res) => {\n    res.render('dashboard-owner', { user: null });\n});\n\n// Initialize database after MongoDB connection is established\nconst connectDB = require('./database/connection');\n(async () => {\n    try {\n        // Wait for MongoDB connection first\n        await connectDB();\n\n        // Then initialize announcements, posts, borders, and shop\n        await initAnnouncementsTable();\n        await initPostsTable();\n        await initBordersTable();\n        await initShopTable();\n        console.log('‚úÖ Announcements, Posts, Borders, and Shop system initialized successfully');\n    } catch (error) {\n        console.error('‚ùå Failed to initialize announcements system:', error);\n    }\n})();\n\n// Main Navigation Routes\napp.get('/home', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    let announcements = [];\n\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    try {\n        announcements = await getRecentAnnouncements(3);\n    } catch (error) {\n        console.error('Error fetching announcements:', error);\n    }\n\n    res.render('home', { user: userData, announcements, isOwner: req.session.isOwner });\n});\n\napp.get('/social', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    let posts = [];\n\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    try {\n        posts = await getRecentPosts(20);\n    } catch (error) {\n        console.error('Error fetching posts:', error);\n    }\n\n    res.render('social', { user: userData, posts, isOwner: req.session.isOwner });\n});\n\n// News route - shows all announcements\napp.get('/news', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    let announcements = [];\n\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    try {\n        announcements = await getAllAnnouncements();\n    } catch (error) {\n        console.error('Error fetching announcements:', error);\n    }\n\n    res.render('news', { user: userData, announcements, isOwner: req.session.isOwner });\n});\n\napp.get('/profile', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    let userBorders = null;\n    let equippedBorder = null;\n\n    if (req.session.userPhone) {\n        try {\n            const userId = req.session.userPhone + '@s.whatsapp.net';\n            userData = await getUser(userId);\n            const userBorderDoc = await getUserBorders(userId);\n            userBorders = userBorderDoc.ownedBorders || [];\n            equippedBorder = await getUserEquippedBorder(userId);\n            \n            console.log('üìã Profile page user borders:', {\n                userId,\n                ownedBordersCount: userBorders.length,\n                ownedBorders: userBorders,\n                equippedBorder: equippedBorder ? equippedBorder.borderId : null\n            });\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('profile', { \n        user: userData, \n        userBorders: userBorders,\n        equippedBorder: equippedBorder\n    });\n});\n\n// API to get available borders for user\napp.get('/api/borders/available', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n        \n        // Get user's borders using the fixed function\n        const userBorderDoc = await getUserBorders(userId);\n        const allBorders = await getAllBorders();\n        \n        console.log('üìä Available borders API:', {\n            userId,\n            allBordersCount: allBorders.length,\n            ownedBordersCount: userBorderDoc.ownedBorders ? userBorderDoc.ownedBorders.length : 0,\n            ownedBorders: userBorderDoc.ownedBorders,\n            equippedBorder: userBorderDoc.equippedBorder\n        });\n\n        res.json({ \n            success: true, \n            borders: allBorders,\n            userBorders: userBorderDoc.ownedBorders || [],\n            equippedBorder: userBorderDoc.equippedBorder\n        });\n    } catch (error) {\n        console.error('‚ùå Error fetching available borders:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to fetch borders: ' + error.message \n        });\n    }\n});\n\n// API to equip border\napp.post('/api/borders/equip', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { borderId } = req.body;\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n\n        if (!borderId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Border ID is required' \n            });\n        }\n\n        console.log('üéØ Equipping border:', { userId, borderId });\n\n        // Get user's border document\n        const { UserBorder } = require('./database/borders');\n        let userBorderDoc = await UserBorder.findOne({ userId });\n        \n        if (!userBorderDoc) {\n            userBorderDoc = new UserBorder({\n                userId,\n                ownedBorders: [{ borderId: 'default' }],\n                equippedBorder: null\n            });\n            await userBorderDoc.save();\n        }\n\n        // Check if user owns this border (default border is always available)\n        const hasBorder = borderId === 'default' || userBorderDoc.ownedBorders.some(border => border.borderId === borderId);\n\n        if (!hasBorder) {\n            return res.status(403).json({ \n                success: false, \n                message: 'You do not own this border' \n            });\n        }\n\n        // Update equipped border\n        userBorderDoc.equippedBorder = borderId;\n        userBorderDoc.updatedAt = new Date();\n        await userBorderDoc.save();\n\n        console.log('‚úÖ Border equipped successfully:', borderId);\n\n        res.json({ \n            success: true, \n            message: 'Border equipped successfully',\n            equippedBorder: borderId\n        });\n    } catch (error) {\n        console.error('‚ùå Error equipping border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to equip border: ' + error.message \n        });\n    }\n});\n\n// API to remove equipped border\napp.post('/api/borders/remove', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n        const result = await equipBorder(userId, null);\n\n        if (result) {\n            res.json({ \n                success: true, \n                message: 'Border removed successfully' \n            });\n        } else {\n            res.status(500).json({ \n                success: false, \n                message: 'Failed to remove border' \n            });\n        }\n    } catch (error) {\n        console.error('Error removing border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to remove border' \n        });\n    }\n});\n\n// API to grant border to user (owner only)\napp.post('/api/borders/grant', async (req, res) => {\n    if (!req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Owner access required' });\n    }\n\n    try {\n        const { userId, borderId } = req.body;\n\n        if (!userId || !borderId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'User ID and Border ID are required' \n            });\n        }\n\n        const result = await addBorderToUser(userId, borderId);\n\n        if (result) {\n            res.json({ \n                success: true, \n                message: 'Border granted successfully' \n            });\n        } else {\n            res.status(500).json({ \n                success: false, \n                message: 'Failed to grant border' \n            });\n        }\n    } catch (error) {\n        console.error('Error granting border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to grant border' \n        });\n    }\n});\n\n// List Menu Routes\napp.get('/shop', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('shop', { user: userData });\n});\n\napp.get('/redeem', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('redeem', { user: userData });\n});\n\napp.get('/member', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('member', { user: userData });\n});\n\napp.get('/quest', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('quest', { user: userData });\n});\n\napp.get('/tournament', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('tournament', { user: userData });\n});\n\napp.get('/mine', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('mine', { user: userData });\n});\n\napp.get('/tower', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('tower', { user: userData });\n});\n\napp.get('/coinflip', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.redirect('/');\n    }\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    res.render('coinflip', { user: userData });\n});\n\napp.get('/dashboard-owner', async (req, res) => {\n    console.log('üîç Dashboard owner access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n    console.log('üîç Session isAuthenticated:', req.session.isAuthenticated);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n            console.log('üîç User data status:', userData ? userData.status : 'no user data');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner either by session or by user status in database\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    // Temporarily remove authentication for testing - will be restored later\n    if (!isOwner && false) { // Note: temporarily disabled with && false\n        console.log('‚ùå Access denied to dashboard-owner - not owner');\n        return res.redirect('/');\n    }\n\n    console.log('‚úÖ Access granted to dashboard-owner');\n    res.render('dashboard-owner', { user: userData });\n});\n\n// User Manager Route\napp.get('/owner/user-manager', async (req, res) => {\n    console.log('üîç User Manager access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        console.log('‚ùå Access denied to user-manager - not owner');\n        return res.redirect('/');\n    }\n\n    // Get all users from database\n    let allUsers = [];\n    try {\n        const User = require('./database/models/User');\n        allUsers = await User.find({}).sort({ createdAt: -1 });\n    } catch (error) {\n        console.error('Error fetching users:', error);\n    }\n\n    console.log('‚úÖ Access granted to user-manager');\n    res.render('user-manager', { user: userData, users: allUsers, isOwner: true });\n});\n\n// Border Manager Route\napp.get('/owner/border-manager', async (req, res) => {\n    console.log('üîç Border Manager access attempt');\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        console.log('‚ùå Access denied to border-manager - not owner');\n        return res.redirect('/');\n    }\n\n    // Get all borders from database\n    let borders = [];\n    try {\n        borders = await getAllBorders();\n    } catch (error) {\n        console.error('Error fetching borders:', error);\n    }\n\n    console.log('‚úÖ Access granted to border-manager');\n    res.render('border-manager', { user: userData, borders, isOwner: true });\n});\n\n// Shop Manager Route\napp.get('/owner/shop-manager', async (req, res) => {\n    console.log('üîç Shop Manager access attempt');\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        console.log('‚ùå Access denied to shop-manager - not owner');\n        return res.redirect('/');\n    }\n\n    console.log('‚úÖ Access granted to shop-manager');\n    res.render('shop-manager', { user: userData, isOwner: true });\n});\n\napp.get('/login', (req, res) => {\n    res.render('login');\n});\n\napp.get('/owner', (req, res) => {\n    res.render('owner');\n});\n\napp.post('/owner-auth', (req, res) => {\n    const { password } = req.body;\n\n    if (password === 'Faratama') {\n        req.session.isOwner = true;\n        res.render('qr-scanner');\n    } else {\n        res.render('owner', { error: 'Password salah!' });\n    }\n});\n\napp.post('/verify-phone', async (req, res) => {\n    const { phone } = req.body;\n\n    console.log(`üìû Verification request for phone: ${phone}`);\n\n    // Generate 6 digit verification code\n    const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n    console.log(`üîê Generated verification code: ${verificationCode}`);\n\n    // Store code with phone number\n    verificationCodes.set(phone, {\n        code: verificationCode,\n        timestamp: Date.now(),\n        attempts: 0\n    });\n\n    // Send verification code via WhatsApp bot\n    console.log(`üì§ Attempting to send verification code...`);\n    const codeSent = await sendVerificationCode(phone, verificationCode);\n\n    if (!codeSent) {\n        console.log(`‚ö†Ô∏è Could not send code via WhatsApp, logging code for manual testing: ${verificationCode}`);\n        console.log(`üîç Please check if bot is properly connected and phone number is correct`);\n    } else {\n        console.log(`‚úÖ Verification code sent successfully to ${phone}`);\n    }\n\n    // Auto-delete code after 5 minutes\n    setTimeout(() => {\n        verificationCodes.delete(phone);\n        console.log(`üóëÔ∏è Verification code for ${phone} expired and deleted`);\n    }, 5 * 60 * 1000);\n\n    res.render('verify-code', { phone, codeSent });\n});\n\napp.post('/verify-code', async (req, res) => {\n    const { phone, code } = req.body;\n\n    const storedData = verificationCodes.get(phone);\n\n    if (!storedData) {\n        return res.render('verify-code', { \n            phone, \n            error: 'Kode verifikasi sudah kedaluwarsa. Silakan coba lagi.' \n        });\n    }\n\n    if (storedData.attempts >= 3) {\n        verificationCodes.delete(phone);\n        return res.render('login', { \n            error: 'Terlalu banyak percobaan. Silakan kirim ulang kode verifikasi.' \n        });\n    }\n\n    if (storedData.code === code) {\n        // Code is correct\n        verificationCodes.delete(phone);\n        req.session.userPhone = phone;\n        req.session.isAuthenticated = true;\n\n        // Create or get user from database\n        try {\n            await createUser(phone + '@s.whatsapp.net', {});\n            res.redirect('/home');\n        } catch (error) {\n            console.error('Error creating user:', error);\n            res.render('login', { error: 'Terjadi kesalahan. Silakan coba lagi.' });\n        }\n    } else {\n        // Incorrect code\n        storedData.attempts++;\n        res.render('verify-code', { \n            phone, \n            error: 'Kode verifikasi salah. Silakan coba lagi.' \n        });\n    }\n});\n\napp.get('/dashboard', async (req, res) => {\n    // Redirect dashboard to home page\n    res.redirect('/home');\n});\n\napp.post('/resend-code', async (req, res) => {\n    const { phone } = req.body;\n\n    console.log(`üîÑ Resend verification request for phone: ${phone}`);\n\n    // Generate new 6 digit verification code\n    const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();\n    console.log(`üîê Generated new verification code: ${verificationCode}`);\n\n    // Store new code with phone number\n    verificationCodes.set(phone, {\n        code: verificationCode,\n        timestamp: Date.now(),\n        attempts: 0\n    });\n\n    // Send verification code via WhatsApp bot\n    console.log(`üì§ Attempting to resend verification code...`);\n    const codeSent = await sendVerificationCode(phone, verificationCode);\n\n    if (!codeSent) {\n        console.log(`‚ö†Ô∏è Could not resend code via WhatsApp, logging code for manual testing: ${verificationCode}`);\n        console.log(`üîç Please check if bot is properly connected and phone number is correct`);\n    } else {\n        console.log(`‚úÖ Verification code resent successfully to ${phone}`);\n    }\n\n    // Auto-delete code after 5 minutes\n    setTimeout(() => {\n        verificationCodes.delete(phone);\n        console.log(`üóëÔ∏è Resent verification code for ${phone} expired and deleted`);\n    }, 5 * 60 * 1000);\n\n    res.render('verify-code', { \n        phone, \n        codeSent,\n        message: codeSent ? 'Kode verifikasi baru telah dikirim!' : 'Bot tidak terhubung. Kode verifikasi di-log ke console.' \n    });\n});\n\napp.get('/api/bot-status', (req, res) => {\n    const isConnected = botInstance && botInstance.isConnected && botInstance.sock;\n    console.log(`üîç Bot status check: ${isConnected ? 'CONNECTED' : 'NOT CONNECTED'}`);\n    console.log(`üîç Bot instance exists: ${!!botInstance}`);\n    console.log(`üîç Bot isConnected flag: ${botInstance ? botInstance.isConnected : 'N/A'}`);\n    console.log(`üîç Bot socket exists: ${botInstance && botInstance.sock ? 'YES' : 'NO'}`);\n\n    if (isConnected) {\n        res.json({ \n            connected: true, \n            message: 'Bot WhatsApp sudah terhubung!',\n            timestamp: new Date().toISOString()\n        });\n    } else {\n        res.json({ \n            connected: false, \n            message: 'Bot belum terhubung, silakan scan QR code',\n            hasQR: !!currentQRCode,\n            timestamp: new Date().toISOString()\n        });\n    }\n});\n\napp.get('/api/qr-code', async (req, res) => {\n    try {\n        console.log('üì± QR code requested. Current QR available:', !!currentQRCode);\n\n        if (currentQRCode) {\n            console.log('‚úÖ Generating QR code data URL...');\n            // Generate QR code as data URL with high quality\n            const qrCodeDataURL = await QRCode.toDataURL(currentQRCode, {\n                width: 300,\n                margin: 2,\n                color: {\n                    dark: '#000000',\n                    light: '#FFFFFF'\n                }\n            });\n\n            console.log('‚úÖ QR code generated successfully');\n            res.json({ \n                success: true, \n                qrCode: qrCodeDataURL,\n                message: 'QR code ready'\n            });\n        } else {\n            console.log('‚ö†Ô∏è QR code not available yet');\n            res.json({ \n                success: false, \n                message: 'QR code not available yet. Bot may be starting or already connected.' \n            });\n        }\n    } catch (error) {\n        console.error('‚ùå Error generating QR code:', error.message);\n        res.status(500).json({ \n            success: false, \n            message: 'Error generating QR code: ' + error.message \n        });\n    }\n});\n\n// News Manager Routes (Owner only)\napp.get('/news-manager', async (req, res) => {\n    console.log('üîç News Manager access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n    console.log('üîç Session isAuthenticated:', req.session.isAuthenticated);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n            console.log('üîç User data status:', userData ? userData.status : 'no user data');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner either by session or by user status in database\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner) {\n        console.log('‚ùå Access denied to news-manager - not owner');\n        return res.redirect('/');\n    }\n\n    let announcements = [];\n\n    try {\n        announcements = await getAllAnnouncements();\n    } catch (error) {\n        console.error('Error fetching announcements:', error);\n    }\n\n    console.log('‚úÖ Access granted to news-manager');\n    res.render('news-manager', { announcements, user: userData, isOwner: true });\n});\n\n// API Routes for News Management\napp.post('/api/news/add', async (req, res) => {\n    console.log('üîç API news/add access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n    console.log('üîç Session isAuthenticated:', req.session.isAuthenticated);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n            console.log('üîç User data status:', userData ? userData.status : 'no user data');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner either by session or by user status in database\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner) {\n        console.log('‚ùå Access denied to news/add API - not owner');\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { title, content, author, icon, category } = req.body;\n\n        if (!title || !content || !author) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Title, content, and author are required' \n            });\n        }\n\n        console.log('‚úÖ Adding news with data:', { title, author, icon, category });\n        const newAnnouncement = await addAnnouncement(title, content, author, icon, category);\n        res.json({ \n            success: true, \n            message: 'News added successfully',\n            announcement: newAnnouncement\n        });\n    } catch (error) {\n        console.error('Error adding news:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to add news: ' + error.message \n        });\n    }\n});\n\napp.post('/api/news/update', async (req, res) => {\n    console.log('üîç API news/update access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n    console.log('üîç Session isAuthenticated:', req.session.isAuthenticated);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n            console.log('üîç User data status:', userData ? userData.status : 'no user data');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner either by session or by user status in database\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner) {\n        console.log('‚ùå Access denied to news/update API - not owner');\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { newsId, title, content, author, icon, category } = req.body;\n\n        if (!newsId || !title || !content || !author) {\n            return res.status(400).json({ \n                success: false, \n                message: 'NewsId, title, content, and author are required' \n            });\n        }\n\n        console.log('‚úÖ Updating news with ID:', newsId);\n        const updatedAnnouncement = await updateAnnouncement(newsId, {\n            title,\n            content,\n            author,\n            icon,\n            category\n        });\n\n        if (!updatedAnnouncement) {\n            return res.status(404).json({ \n                success: false, \n                message: 'News not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'News updated successfully',\n            announcement: updatedAnnouncement\n        });\n    } catch (error) {\n        console.error('Error updating news:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to update news: ' + error.message \n        });\n    }\n});\n\napp.delete('/api/news/delete', async (req, res) => {\n    console.log('üîç API news/delete access attempt');\n    console.log('üîç Session isOwner:', req.session.isOwner);\n    console.log('üîç Session isAuthenticated:', req.session.isAuthenticated);\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n            console.log('üîç User data status:', userData ? userData.status : 'no user data');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    // Check if user is owner either by session or by user status in database\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner) {\n        console.log('‚ùå Access denied to news/delete API - not owner');\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { newsId } = req.body;\n\n        if (!newsId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'NewsId is required' \n            });\n        }\n\n        console.log('‚úÖ Deleting news with ID:', newsId);\n        const result = await deleteAnnouncement(newsId);\n\n        if (!result) {\n            return res.status(404).json({ \n                success: false, \n                message: 'News not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'News deleted successfully'\n        });\n    } catch (error) {\n        console.error('Error deleting news:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete news: ' + error.message \n        });\n    }\n});\n\n// Additional upload configuration for posts\nconst postUpload = multer({ \n    storage: multer.diskStorage({\n        destination: function (req, file, cb) {\n            const uploadDir = path.join(__dirname, 'public', 'uploads');\n            // Create directory if it doesn't exist\n            const fs = require('fs');\n            if (!fs.existsSync(uploadDir)) {\n                fs.mkdirSync(uploadDir, { recursive: true });\n            }\n            cb(null, uploadDir);\n        },\n        filename: function (req, file, cb) {\n            const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n            cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n        }\n    }),\n    limits: {\n        fileSize: 10 * 1024 * 1024 // 10MB limit\n    },\n    fileFilter: function (req, file, cb) {\n        // Accept only images and videos\n        if (file.mimetype.startsWith('image/') || file.mimetype.startsWith('video/')) {\n            cb(null, true);\n        } else {\n            cb(new Error('Only image and video files are allowed!'), false);\n        }\n    }\n});\n\n// File upload API\napp.post('/api/upload', postUpload.single('file'), (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    if (!req.file) {\n        return res.status(400).json({ success: false, message: 'No file uploaded' });\n    }\n\n    const fileUrl = `/uploads/${req.file.filename}`;\n    res.json({ \n        success: true, \n        fileUrl: fileUrl,\n        filename: req.file.filename,\n        originalName: req.file.originalname,\n        size: req.file.size\n    });\n});\n\n// Get all posts API\napp.get('/api/posts/all', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const posts = await getRecentPosts(50); // Get more posts for better UX\n        res.json({ \n            success: true, \n            posts: posts\n        });\n    } catch (error) {\n        console.error('Error fetching posts:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to fetch posts: ' + error.message \n        });\n    }\n});\n\n// Delete post API\napp.delete('/api/posts/delete', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { postId } = req.body;\n\n        if (!postId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Post ID is required' \n            });\n        }\n\n        // Get the post first to check ownership\n        const Post = require('./database/models/Post');\n        const post = await Post.findById(postId);\n\n        if (!post) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Post not found' \n            });\n        }\n\n        // Check if user owns the post\n        const currentUserId = req.session.userPhone + '@s.whatsapp.net';\n        if (post.userId !== currentUserId && !req.session.isOwner) {\n            return res.status(403).json({ \n                success: false, \n                message: 'You can only delete your own posts' \n            });\n        }\n\n        // Delete associated media file if exists\n        if (post.mediaUrl) {\n            const fs = require('fs');\n            const filePath = path.join(__dirname, 'public', post.mediaUrl);\n            if (fs.existsSync(filePath)) {\n                fs.unlinkSync(filePath);\n            }\n        }\n\n        const deleted = await deletePost(postId);\n        if (deleted) {\n            res.json({ \n                success: true, \n                message: 'Post deleted successfully'\n            });\n        } else {\n            res.status(500).json({ \n                success: false, \n                message: 'Failed to delete post' \n            });\n        }\n    } catch (error) {\n        console.error('Error deleting post:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete post: ' + error.message \n        });\n    }\n});\n\n// Profile Update API\napp.post('/api/profile/update', upload.single('profilePhoto'), async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { username } = req.body;\n        const userPhone = req.session.userPhone;\n\n        if (!userPhone) {\n            return res.status(400).json({ \n                success: false, \n                message: 'User session not found' \n            });\n        }\n\n        // Check if at least one field is provided\n        if ((!username || username.trim().length === 0) && !req.file) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Please provide either a username or profile photo to update' \n            });\n        }\n\n        const userId = userPhone + '@s.whatsapp.net';\n\n        // Prepare update data\n        const updateData = {};\n\n        // Handle username update (only if provided and not empty)\n        if (username && username.trim().length > 0) {\n            updateData.username = username.trim();\n        }\n\n        // Handle profile photo upload\n        if (req.file) {\n            const photoUrl = `/uploads/${req.file.filename}`;\n            updateData.profilePhoto = photoUrl;\n            console.log(`üì∑ Profile photo uploaded: ${photoUrl}`);\n        }\n\n        // Update user in database\n        const updatedUser = await updateUser(userId, updateData);\n\n        if (!updatedUser) {\n            return res.status(404).json({ \n                success: false, \n                message: 'User not found' \n            });\n        }\n\n        console.log(`‚úÖ Profile updated for user: ${userId}`);\n        console.log(`üìù New username: ${updateData.username}`);\n        if (updateData.profilePhoto) {\n            console.log(`üì∑ New profile photo: ${updateData.profilePhoto}`);\n        }\n\n        res.json({ \n            success: true, \n            message: 'Profile updated successfully',\n            user: {\n                username: updatedUser.username,\n                profilePhoto: updatedUser.profilePhoto\n            }\n        });\n\n    } catch (error) {\n        console.error('‚ùå Error updating profile:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to update profile: ' + error.message \n        });\n    }\n});\n\n// Social Posts API Routes\napp.post('/api/posts/create', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { type, content, mediaUrl } = req.body;\n\n        if (!content) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Content is required' \n            });\n        }\n\n        let userData = null;\n        let author = 'Anonymous';\n        let userId = 'unknown';\n\n        if (req.session.userPhone) {\n            userId = req.session.userPhone + '@s.whatsapp.net';\n            try {\n                userData = await getUser(userId);\n                author = userData ? userData.username : req.session.userPhone;\n            } catch (error) {\n                console.error('Error fetching user data:', error);\n                author = req.session.userPhone;\n            }\n        }\n\n        const newPost = await createPost(userId, author, type || 'text', content, mediaUrl || '');\n        res.json({ \n            success: true, \n            message: 'Post created successfully',\n            post: newPost\n        });\n    } catch (error) {\n        console.error('Error creating post:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to create post: ' + error.message \n        });\n    }\n});\n\napp.post('/api/posts/like', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { postId } = req.body;\n\n        if (!postId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Post ID is required' \n            });\n        }\n\n        const userId = req.session.userPhone ? req.session.userPhone + '@s.whatsapp.net' : 'unknown';\n        const result = await likePost(postId, userId);\n\n        res.json(result);\n    } catch (error) {\n        console.error('Error liking post:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to like post: ' + error.message \n        });\n    }\n});\n\napp.post('/api/posts/unlike', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { postId } = req.body;\n\n        if (!postId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Post ID is required' \n            });\n        }\n\n        const userId = req.session.userPhone ? req.session.userPhone + '@s.whatsapp.net' : 'unknown';\n        const result = await unlikePost(postId, userId);\n\n        res.json(result);\n    } catch (error) {\n        console.error('Error unliking post:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to unlike post: ' + error.message \n        });\n    }\n});\n\napp.post('/api/posts/comment', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { postId, content } = req.body;\n\n        if (!postId || !content) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Post ID and content are required' \n            });\n        }\n\n        let userData = null;\n        let author = 'Anonymous';\n        const userId = req.session.userPhone ? req.session.userPhone + '@s.whatsapp.net' : 'unknown';\n\n        if (req.session.userPhone) {\n            try {\n                userData = await getUser(userId);\n                author = userData ? userData.username : req.session.userPhone;\n            } catch (error) {\n                console.error('Error fetching user data:', error);\n                author = req.session.userPhone;\n            }\n        }\n\n        const result = await addComment(postId, userId, author, content);\n        res.json(result);\n    } catch (error) {\n        console.error('Error adding comment:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to add comment: ' + error.message \n        });\n    }\n});\n\napp.delete('/api/posts/delete', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { postId } = req.body;\n\n        if (!postId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Post ID is required' \n            });\n        }\n\n        // TODO: Add authorization check to ensure user can only delete their own posts\n        const result = await deletePost(postId);\n\n        if (!result) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Post not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Post deleted successfully'\n        });\n    } catch (error) {\n        console.error('Error deleting post:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete post: ' + error.message \n        });\n    }\n});\n\n// User Management API Routes\napp.get('/api/users/all', async (req, res) => {\n    console.log('üîç API users/all access attempt');\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const User = require('./database/models/User');\n        const users = await User.find({}).sort({ createdAt: -1 });\n        res.json({ success: true, users });\n    } catch (error) {\n        console.error('Error fetching users:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to fetch users: ' + error.message \n        });\n    }\n});\n\napp.put('/api/users/update', async (req, res) => {\n    console.log('üîç API users/update access attempt');\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { userId, updateData } = req.body;\n\n        if (!userId || !updateData) {\n            return res.status(400).json({ \n                success: false, \n                message: 'User ID and update data are required' \n            });\n        }\n\n        const User = require('./database/models/User');\n        const updatedUser = await User.findByIdAndUpdate(userId, updateData, { new: true });\n\n        if (!updatedUser) {\n            return res.status(404).json({ \n                success: false, \n                message: 'User not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'User updated successfully',\n            user: updatedUser\n        });\n    } catch (error) {\n        console.error('Error updating user:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to update user: ' + error.message \n        });\n    }\n});\n\napp.delete('/api/users/delete', async (req, res) => {\n    console.log('üîç API users/delete access attempt');\n\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { userId } = req.body;\n\n        if (!userId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'User ID is required' \n            });\n        }\n\n        const User = require('./database/models/User');\n        const deletedUser = await User.findByIdAndDelete(userId);\n\n        if (!deletedUser) {\n            return res.status(404).json({ \n                success: false, \n                message: 'User not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'User deleted successfully'\n        });\n    } catch (error) {\n        console.error('Error deleting user:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete user: ' + error.message \n        });\n    }\n});\n\napp.post('/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            console.error('Error destroying session:', err);\n            return res.status(500).json({ success: false, message: 'Logout failed' });\n        }\n        console.log('‚úÖ User logged out successfully');\n        res.redirect('/login');\n    });\n});\n\n// Handle GET request for logout as well (in case someone accesses it directly)\napp.get('/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            console.error('Error destroying session:', err);\n        }\n        console.log('‚úÖ User logged out successfully');\n        res.redirect('/login');\n    });\n});\n\napp.put('/api/users/:id', async (req, res) => {\n    try {\n        const { balance, chips, xp, level, status } = req.body;\n\n        const User = require('./database/models/User');\n        const user = await User.findById(req.params.id);\n        if (!user) {\n            return res.status(404).json({ success: false, message: 'User not found' });\n        }\n\n        // Update user data\n        if (balance !== undefined) user.balance = balance;\n        if (chips !== undefined) user.chips = chips;\n        if (xp !== undefined) user.xp = xp;\n        if (level !== undefined) user.level = level;\n        if (status !== undefined) user.status = status;\n\n        await user.save();\n\n        // Get updated user with rank information\n        const updatedUser = await User.findById(req.params.id);\n        const currentRank = updatedUser.getCurrentRank();\n\n        res.json({ \n            success: true, \n            message: 'User updated successfully',\n            user: {\n                ...updatedUser.toObject(),\n                rank: currentRank\n            }\n        });\n    } catch (error) {\n        console.error('Error updating user:', error);\n        res.status(500).json({ success: false, message: 'Failed to update user' });\n    }\n});\n\n// Border API Routes\n// Get all borders\napp.get('/api/borders', async (req, res) => {\n    try {\n        const borders = await getAllBorders();\n        res.json({ success: true, data: borders });\n    } catch (error) {\n        console.error('Error fetching borders:', error);\n        res.status(500).json({ success: false, message: 'Failed to fetch borders' });\n    }\n});\n\n// Get single border\napp.get('/api/borders/:id', async (req, res) => {\n    try {\n        const border = await getBorderById(req.params.id);\n        if (!border) {\n            return res.status(404).json({ success: false, message: 'Border not found' });\n        }\n        res.json({ success: true, data: border });\n    } catch (error) {\n        console.error('Error fetching border:', error);\n        res.status(500).json({ success: false, message: 'Failed to fetch border' });\n    }\n});\n\n// Create new border\napp.post('/api/borders', upload.single('borderImage'), async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { borderId, name, description, rarity } = req.body;\n\n        if (!borderId || !name || !req.file) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Border ID, name, and image are required' \n            });\n        }\n\n        // Check if border ID already exists\n        const existingBorder = await getBorderById(borderId);\n        if (existingBorder) {\n            return res.status(409).json({ \n                success: false, \n                message: 'Border ID already exists' \n            });\n        }\n\n        const borderData = {\n            borderId,\n            name,\n            description: description || '',\n            rarity: rarity || 'common',\n            imageUrl: `/borders/${req.file.filename}`,\n            createdBy: userData ? userData.userId : 'unknown'\n        };\n\n        const newBorder = await createBorder(borderData);\n\n        if (!newBorder) {\n            return res.status(500).json({ \n                success: false, \n                message: 'Failed to create border' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Border created successfully',\n            data: newBorder\n        });\n    } catch (error) {\n        console.error('Error creating border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to create border: ' + error.message \n        });\n    }\n});\n\n// Update border\napp.put('/api/borders/:id', upload.single('borderImage'), async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const originalBorderId = req.params.id;\n        const { borderId, name, description, rarity } = req.body;\n\n        const updateData = {\n            borderId: borderId || originalBorderId,\n            name,\n            description: description || '',\n            rarity: rarity || 'common'\n        };\n\n        // If new image is uploaded, update the image URL\n        if (req.file) {\n            updateData.imageUrl = `/borders/${req.file.filename}`;\n        }\n\n        const updatedBorder = await updateBorder(originalBorderId, updateData);\n\n        if (!updatedBorder) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Border not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Border updated successfully',\n            data: updatedBorder\n        });\n    } catch (error) {\n        console.error('Error updating border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to update border: ' + error.message \n        });\n    }\n});\n\n// Delete border\napp.delete('/api/borders/:id', async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const borderId = req.params.id;\n\n        // Prevent deletion of default border\n        if (borderId === 'default') {\n            return res.status(400).json({ \n                success: false, \n                message: 'Cannot delete default border' \n            });\n        }\n\n        const deletedBorder = await deleteBorder(borderId);\n\n        if (!deletedBorder) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Border not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Border deleted successfully'\n        });\n    } catch (error) {\n        console.error('Error deleting border:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete border: ' + error.message \n        });\n    }\n});\n\n// User Border Management APIs\n// Get user's borders\napp.get('/api/user/borders', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(401).json({ success: false, message: 'Authentication required' });\n    }\n\n    try {\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n        const userBorders = await getUserBorders(userId);\n        const allBorders = await getAllBorders();\n\n        // Get border details for owned borders\n        const ownedBordersWithDetails = await Promise.all(\n            userBorders.ownedBorders.map(async (ownedBorder) => {\n                const borderDetails = await getBorderById(ownedBorder.borderId);\n                return {\n                    ...borderDetails.toObject(),\n                    obtainedAt: ownedBorder.obtainedAt\n                };\n            })\n        );\n\n        res.json({ \n            success: true, \n            data: {\n                ownedBorders: ownedBordersWithDetails,\n                equippedBorder: userBorders.equippedBorder,\n                allBorders\n            }\n        });\n    } catch (error) {\n        console.error('Error fetching user borders:', error);\n        res.status(500).json({ success: false, message: 'Failed to fetch borders' });\n    }\n});\n\n// Equip border\napp.post('/api/user/equip-border', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(401).json({ success: false, message: 'Authentication required' });\n    }\n\n    try {\n        const { borderId } = req.body;\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n\n        const result = await equipBorder(userId, borderId);\n\n        if (!result.success) {\n            return res.status(400).json(result);\n        }\n\n        res.json(result);\n    } catch (error) {\n        console.error('Error equipping border:', error);\n        res.status(500).json({ success: false, message: 'Failed to equip border' });\n    }\n});\n\n// Add border to user (admin only)\napp.post('/api/user/:userId/add-border', async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { userId } = req.params;\n        const { borderId } = req.body;\n\n        const result = await addBorderToUser(userId, borderId);\n\n        if (!result.success) {\n            return res.status(400).json(result);\n        }\n\n        res.json(result);\n    } catch (error) {\n        console.error('Error adding border to user:', error);\n        res.status(500).json({ success: false, message: 'Failed to add border' });\n    }\n});\n\n// Shop API Routes\n// Get all shop items\napp.get('/api/shop/items', async (req, res) => {\n    try {\n        const items = await getAllShopItems();\n        res.json({ success: true, items });\n    } catch (error) {\n        console.error('Error fetching shop items:', error);\n        res.status(500).json({ success: false, message: 'Failed to fetch shop items' });\n    }\n});\n\n// Add new shop item (owner only)\napp.post('/api/shop/items/add', upload.single('imageFile'), async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { name, description, category, price, priceType, stock } = req.body;\n\n        if (!name || !category || !price || !priceType || !stock) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Name, category, price, priceType, and stock are required' \n            });\n        }\n\n        const itemData = {\n            name,\n            description: description || '',\n            category,\n            price: parseInt(price),\n            priceType,\n            stock: parseInt(stock),\n            purchaseLimit: req.body.purchaseLimit || 'unlimited',\n            imageUrl: req.file ? `/uploads/${req.file.filename}` : '',\n            createdBy: userData ? userData.userId : 'unknown'\n        };\n\n        const newItem = await createShopItem(itemData);\n\n        if (!newItem) {\n            return res.status(500).json({ \n                success: false, \n                message: 'Failed to create shop item' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Shop item created successfully',\n            item: newItem\n        });\n    } catch (error) {\n        console.error('Error creating shop item:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to create shop item: ' + error.message \n        });\n    }\n});\n\n// Update shop item (owner only)\napp.post('/api/shop/items/update', upload.single('imageFile'), async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { itemId, name, description, category, price, priceType, stock } = req.body;\n\n        if (!itemId || !name || !category || !price || !priceType || !stock) {\n            return res.status(400).json({ \n                success: false, \n                message: 'ItemId, name, category, price, priceType, and stock are required' \n            });\n        }\n\n        const updateData = {\n            name,\n            description: description || '',\n            category,\n            price: parseInt(price),\n            priceType,\n            stock: parseInt(stock),\n            purchaseLimit: req.body.purchaseLimit || 'unlimited'\n        };\n\n        // If new image is uploaded, update the image URL\n        if (req.file) {\n            updateData.imageUrl = `/uploads/${req.file.filename}`;\n        }\n\n        const updatedItem = await updateShopItem(itemId, updateData);\n\n        if (!updatedItem) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Shop item not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Shop item updated successfully',\n            item: updatedItem\n        });\n    } catch (error) {\n        console.error('Error updating shop item:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to update shop item: ' + error.message \n        });\n    }\n});\n\n// Delete shop item (owner only)\napp.delete('/api/shop/items/delete', async (req, res) => {\n    let userData = null;\n    if (req.session.userPhone) {\n        try {\n            userData = await getUser(req.session.userPhone + '@s.whatsapp.net');\n        } catch (error) {\n            console.error('Error fetching user data:', error);\n        }\n    }\n\n    const isOwner = req.session.isOwner || (userData && userData.status === 'owner');\n\n    if (!isOwner && false) { // Temporarily disabled\n        return res.status(403).json({ success: false, message: 'Access denied' });\n    }\n\n    try {\n        const { itemId } = req.body;\n\n        if (!itemId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'ItemId is required' \n            });\n        }\n\n        const deletedItem = await deleteShopItem(itemId);\n\n        if (!deletedItem) {\n            return res.status(404).json({ \n                success: false, \n                message: 'Shop item not found' \n            });\n        }\n\n        res.json({ \n            success: true, \n            message: 'Shop item deleted successfully'\n        });\n    } catch (error) {\n        console.error('Error deleting shop item:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to delete shop item: ' + error.message \n        });\n    }\n});\n\n// Purchase item\napp.post('/api/shop/purchase', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(401).json({ success: false, message: 'Authentication required' });\n    }\n\n    try {\n        const { itemId } = req.body;\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n\n        if (!itemId) {\n            return res.status(400).json({ \n                success: false, \n                message: 'Item ID is required' \n            });\n        }\n\n        const result = await purchaseItem(userId, itemId);\n\n        if (result.success) {\n            res.json(result);\n        } else {\n            res.status(400).json(result);\n        }\n    } catch (error) {\n        console.error('Error purchasing item:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to purchase item: ' + error.message \n        });\n    }\n});\n\n// Get user purchase history\napp.get('/api/shop/history', async (req, res) => {\n    if (!req.session.isAuthenticated && !req.session.isOwner) {\n        return res.status(401).json({ success: false, message: 'Authentication required' });\n    }\n\n    try {\n        const userId = req.session.userPhone + '@s.whatsapp.net';\n        const history = await getUserPurchaseHistory(userId);\n\n        res.json({ \n            success: true, \n            history \n        });\n    } catch (error) {\n        console.error('Error fetching purchase history:', error);\n        res.status(500).json({ \n            success: false, \n            message: 'Failed to fetch purchase history' \n        });\n    }\n});\n\napp.listen(PORT, '0.0.0.0', () => {\n    console.log('üåê Web server running on http://0.0.0.0:' + PORT);\n});\n\nmodule.exports = { app, setBotInstance, setQRCode };","size_bytes":70825},"troubleshoot.js":{"content":"#!/usr/bin/env node\n\n// Troubleshooting script for Seana Bot deployment issues\nconst fs = require('fs');\nconst path = require('path');\n\nconsole.log('üîß Seana Bot Troubleshooting Tool');\nconsole.log('==================================\\n');\n\n// Check Node.js version\nconsole.log('üìã System Check:');\nconsole.log(`   Node.js version: ${process.version}`);\nconsole.log(`   Platform: ${process.platform}`);\nconsole.log(`   Architecture: ${process.arch}\\n`);\n\n// Check if Node.js version meets requirements\nconst nodeVersion = parseInt(process.version.slice(1).split('.')[0]);\nif (nodeVersion < 20) {\n    console.log('‚ùå Node.js version check FAILED');\n    console.log('   @whiskeysockets/baileys requires Node.js 20+');\n    console.log(`   Current version: ${process.version}`);\n    console.log('   Please upgrade to Node.js 20+\\n');\n} else {\n    console.log('‚úÖ Node.js version check PASSED\\n');\n}\n\n// Check package.json\nconsole.log('üì¶ Package Check:');\ntry {\n    const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));\n    \n    // Check engines field\n    if (packageJson.engines && packageJson.engines.node) {\n        console.log(`   Engines.node: ${packageJson.engines.node}`);\n    } else {\n        console.log('   ‚ö†Ô∏è  No engines.node field found in package.json');\n    }\n    \n    // Check baileys version\n    if (packageJson.dependencies && packageJson.dependencies['@whiskeysockets/baileys']) {\n        console.log(`   Baileys version: ${packageJson.dependencies['@whiskeysockets/baileys']}`);\n    }\n    \n    console.log('‚úÖ package.json check PASSED\\n');\n} catch (error) {\n    console.log('‚ùå package.json check FAILED');\n    console.log(`   Error: ${error.message}\\n`);\n}\n\n// Check required files\nconsole.log('üìÅ File Check:');\nconst requiredFiles = [\n    'index.js',\n    'server.js',\n    'config/config.js',\n    'database/connection.js',\n    'Dockerfile',\n    'railway.json',\n    '.dockerignore'\n];\n\nconst missingFiles = [];\nrequiredFiles.forEach(file => {\n    if (fs.existsSync(file)) {\n        console.log(`   ‚úÖ ${file}`);\n    } else {\n        console.log(`   ‚ùå ${file} - MISSING`);\n        missingFiles.push(file);\n    }\n});\n\nif (missingFiles.length > 0) {\n    console.log(`\\n   ‚ö†Ô∏è  Missing ${missingFiles.length} required files`);\n}\nconsole.log();\n\n// Check Dockerfile\nconsole.log('üê≥ Dockerfile Check:');\ntry {\n    const dockerfile = fs.readFileSync('Dockerfile', 'utf8');\n    \n    if (dockerfile.includes('node:20')) {\n        console.log('   ‚úÖ Using Node.js 20');\n    } else if (dockerfile.includes('node:18')) {\n        console.log('   ‚ùå Using Node.js 18 - needs upgrade to 20');\n    } else {\n        console.log('   ‚ö†Ô∏è  Node.js version not clearly specified');\n    }\n    \n    if (dockerfile.includes('npm ci --omit=dev')) {\n        console.log('   ‚úÖ Using correct npm install command');\n    } else if (dockerfile.includes('npm ci --only=production')) {\n        console.log('   ‚ö†Ô∏è  Using deprecated --only=production flag');\n    }\n    \n    console.log();\n} catch (error) {\n    console.log('   ‚ùå Cannot read Dockerfile');\n    console.log(`   Error: ${error.message}\\n`);\n}\n\n// Check environment variables\nconsole.log('üîê Environment Variables Check:');\nconst requiredEnvVars = ['NODE_ENV', 'PORT', 'MONGODB_URI'];\nconst missingEnvVars = [];\n\nrequiredEnvVars.forEach(envVar => {\n    if (process.env[envVar]) {\n        console.log(`   ‚úÖ ${envVar}`);\n    } else {\n        console.log(`   ‚ùå ${envVar} - MISSING`);\n        missingEnvVars.push(envVar);\n    }\n});\n\nif (missingEnvVars.length > 0) {\n    console.log(`\\n   ‚ö†Ô∏è  Missing ${missingEnvVars.length} environment variables`);\n    console.log('   Create .env file or set in Railway dashboard');\n}\nconsole.log();\n\n// Check MongoDB connection\nconsole.log('üçÉ MongoDB Connection Check:');\nif (process.env.MONGODB_URI) {\n    if (process.env.MONGODB_URI.startsWith('mongodb://') || process.env.MONGODB_URI.startsWith('mongodb+srv://')) {\n        console.log('   ‚úÖ MongoDB URI format looks correct');\n    } else {\n        console.log('   ‚ùå MongoDB URI format looks incorrect');\n    }\n} else {\n    console.log('   ‚ùå MONGODB_URI not set');\n}\nconsole.log();\n\n// Summary and recommendations\nconsole.log('üìä Summary & Recommendations:');\nconsole.log('==============================');\n\nif (nodeVersion < 20) {\n    console.log('üî¥ CRITICAL: Upgrade to Node.js 20+');\n    console.log('   - Update Dockerfile to use node:20-alpine');\n    console.log('   - Set NODE_VERSION=20 in Railway environment variables');\n}\n\nif (missingFiles.length > 0) {\n    console.log('üü° WARNING: Missing required files');\n    console.log('   - Ensure all files are committed to repository');\n}\n\nif (missingEnvVars.length > 0) {\n    console.log('üü° WARNING: Missing environment variables');\n    console.log('   - Set in Railway dashboard or .env file');\n}\n\nconsole.log('\\nüöÄ Deployment Commands:');\nconsole.log('   railway login');\nconsole.log('   railway init');\nconsole.log('   railway up');\nconsole.log('\\nüìñ For detailed help, see DEPLOYMENT.md');","size_bytes":5063},"commands/menu.js":{"content":"const config = require('../config/config');\n\nconst menuCommand = async (sock, from, sender, args) => {\n    try {\n        // Replace botName placeholder with actual bot name\n        const menuText = config.messages.menuMessage\n            .replace(/{botName}/g, config.botName.toUpperCase());\n        \n        await sock.sendMessage(from, { \n            text: menuText,\n            mentions: [config.ownerNumber]\n        });\n        \n        return true;\n    } catch (error) {\n        console.error('‚ùå Error in menu command:', error.message);\n        await sock.sendMessage(from, { \n            text: config.messages.databaseError \n        });\n        return false;\n    }\n};\n\nmodule.exports = {\n    name: 'menu',\n    description: 'Show bot menu and available commands',\n    usage: '.menu',\n    category: 'general',\n    requiresLimit: false,\n    execute: menuCommand\n};\n","size_bytes":870},"commands/ping.js":{"content":"const config = require('../config/config');\n\nconst pingCommand = async (sock, from, sender, args) => {\n    try {\n        const startTime = Date.now();\n        \n        // Send initial message\n        const sentMessage = await sock.sendMessage(from, { \n            text: 'üèì Calculating ping...' \n        });\n        \n        const endTime = Date.now();\n        const responseTime = endTime - startTime;\n        \n        // Edit the message with actual ping\n        const pingText = config.messages.pingMessage.replace('{responseTime}', responseTime);\n        \n        await sock.sendMessage(from, { \n            text: pingText,\n            edit: sentMessage.key\n        });\n        \n        return true;\n    } catch (error) {\n        console.error('‚ùå Error in ping command:', error.message);\n        await sock.sendMessage(from, { \n            text: config.messages.databaseError \n        });\n        return false;\n    }\n};\n\nmodule.exports = {\n    name: 'ping',\n    description: 'Check bot response time and status',\n    usage: '.ping',\n    category: 'general',\n    requiresLimit: false,\n    execute: pingCommand\n};\n","size_bytes":1120},"commands/profile.js":{"content":"const config = require('../config/config');\nconst { getUser } = require('../utils/userUtils');\n\nconst profileCommand = async (sock, from, sender, args, message) => {\n    try {\n        // Get user data\n        const user = await getUser(sender);\n        if (!user) {\n            await sock.sendMessage(from, { \n                text: config.messages.databaseError \n            });\n            return false;\n        }\n        \n        // Check if user has enough limits\n        if (user.limit < 1) {\n            await sock.sendMessage(from, { \n                text: config.messages.insufficientLimit \n            });\n            return false;\n        }\n        \n        // Get WhatsApp profile name from multiple sources\n        let whatsappName = 'User';\n        \n        // Try to get name from message pushName first\n        if (message && message.pushName) {\n            whatsappName = message.pushName;\n        } else {\n            // Try other methods\n            try {\n                // Try getting contact info\n                const contactInfo = await sock.onWhatsApp(sender);\n                if (contactInfo && contactInfo[0] && contactInfo[0].notify) {\n                    whatsappName = contactInfo[0].notify;\n                }\n            } catch (error) {\n                console.log('Could not fetch WhatsApp name from onWhatsApp');\n            }\n            \n            // If still no name, try getting from chat\n            if (whatsappName === 'User') {\n                try {\n                    const chat = await sock.chatRead(from);\n                    if (chat && chat.name) {\n                        whatsappName = chat.name;\n                    }\n                } catch (error) {\n                    console.log('Could not fetch name from chat');\n                }\n            }\n        }\n        \n        console.log(`üìù Using WhatsApp name: ${whatsappName} for user: ${sender}`);\n        \n        // Deduct limit silently (no notification)\n        user.deductLimit(1);\n        user.updateActivity();\n        await user.save();\n        \n        // Format limit display based on user status\n        let limitDisplay = '';\n        if (user.hasUnlimitedLimits()) {\n            limitDisplay = '‚àû (unlimited)';\n        } else {\n            limitDisplay = `${user.limit}/${user.totalLimit}`;\n        }\n        \n        // Format profile message\n        const profileText = config.messages.profileMessage\n            .replace('{username}', whatsappName)\n            .replace('{tag}', `@${sender.split('@')[0]}`)\n            .replace('{status}', user.status.toUpperCase())\n            .replace('{limitDisplay}', limitDisplay)\n            .replace('{balance}', user.balance)\n            .replace('{chips}', user.chips)\n            .replace('{memberSince}', user.getFormattedMemberSince());\n        \n        // Get profile picture\n        let profilePicUrl = null;\n        try {\n            profilePicUrl = await sock.profilePictureUrl(sender, 'image');\n        } catch (error) {\n            console.log('Could not fetch profile picture');\n        }\n        \n        // Send profile info with picture if available\n        if (profilePicUrl) {\n            await sock.sendMessage(from, {\n                image: { url: profilePicUrl },\n                caption: profileText,\n                mentions: [sender]\n            });\n        } else {\n            // Send without image if profile picture is not available\n            await sock.sendMessage(from, { \n                text: profileText,\n                mentions: [sender]\n            });\n        }\n        \n        return true;\n    } catch (error) {\n        console.error('‚ùå Error in profile command:', error.message);\n        await sock.sendMessage(from, { \n            text: config.messages.databaseError \n        });\n        return false;\n    }\n};\n\nmodule.exports = {\n    name: 'profile',\n    description: 'View your user profile and statistics',\n    usage: '.profile',\n    category: 'user',\n    requiresLimit: true,\n    limitCost: 1,\n    execute: profileCommand\n};\n","size_bytes":4041},"commands/sticker.js":{"content":"const config = require('../config/config');\nconst { createSticker, downloadMedia, isImageMessage, getImageMessage } = require('../utils/stickerUtils');\n\nconst stickerCommand = async (sock, from, sender, args, message) => {\n    try {\n        // Check if it's a reply to an image message\n        const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;\n        let targetMessage = null;\n\n        if (quotedMessage) {\n            // It's a reply - check if quoted message has image\n            if (quotedMessage.imageMessage || \n                quotedMessage.viewOnceMessage?.message?.imageMessage ||\n                quotedMessage.ephemeralMessage?.message?.imageMessage) {\n                \n                // Create a message object for the quoted content\n                targetMessage = {\n                    message: quotedMessage,\n                    key: message.message.extendedTextMessage.contextInfo.participant \n                        ? { participant: message.message.extendedTextMessage.contextInfo.participant }\n                        : { remoteJid: from }\n                };\n            }\n        } else {\n            // Check if current message has image\n            if (isImageMessage(message)) {\n                targetMessage = message;\n            }\n        }\n\n        // If no image found\n        if (!targetMessage) {\n            await sock.sendMessage(from, {\n                text: '‚ùå Penggunaan salah!\\n\\n' +\n                      'üìù Cara Penggunaan:\\n' +\n                      '‚Ä¢ Reply ke gambar: .s / .sticker\\n' +\n                      '‚Ä¢ Kirim gambar: .s / .sticker \\n' \n            });\n            return false;\n        }\n\n        // Send processing message\n        await sock.sendMessage(from, {\n            text: '‚è≥ Sedang membuat sticker... Tunggu bentar yaa!'\n        });\n\n        try {\n            // Download the image\n            console.log('üì• Downloading image for sticker conversion...');\n            const imageBuffer = await downloadMedia(targetMessage);\n            \n            if (!imageBuffer) {\n                throw new Error('Failed to download image');\n            }\n\n            console.log('üé® Converting image to sticker...');\n            // Create sticker\n            const stickerBuffer = await createSticker(\n                imageBuffer, \n                config.sticker.pack, \n                config.sticker.author\n            );\n\n            // Send sticker \n            console.log('üì§ Sending sticker...');\n            await sock.sendMessage(from, {\n                sticker: stickerBuffer\n            });\n\n            console.log('‚úÖ Sticker sent successfully');\n            \n        } catch (conversionError) {\n            console.error('‚ùå Sticker conversion error:', conversionError.message);\n            \n            await sock.sendMessage(from, {\n                text: '‚ùå Failed to create sticker. Please make sure:\\n' +\n                      '‚Ä¢ The image is valid (JPG, PNG, WebP)\\n' +\n                      '‚Ä¢ The image is not corrupted\\n' +\n                      '‚Ä¢ Try with a different image'\n            });\n            return false;\n        }\n\n        return true;\n\n    } catch (error) {\n        console.error('‚ùå Sticker command error:', error.message);\n        \n        await sock.sendMessage(from, {\n            text: '‚ùå An error occurred while processing the sticker. Please try again later.'\n        });\n        \n        return false;\n    }\n};\n\nmodule.exports = {\n    name: 'sticker',\n    aliases: ['s'],\n    description: 'Convert image to sticker (1 limit)',\n    usage: '.s/.sticker (reply to image or send with image)',\n    category: 'media',\n    requiresLimit: true,\n    limitCost: 1,\n    execute: stickerCommand\n};","size_bytes":3749},"config/config.js":{"content":"module.exports = {\n    // Bot Configuration\n    botName: 'seana bot',\n    ownerNumber: '6285709557572@s.whatsapp.net',\n    \n    // Database Configuration\n    mongoURI: process.env.MONGO_URI || 'mongodb+srv://pioo:Avionika27@cluster0.feboa.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0',\n    \n    // User Default Settings\n    defaultSettings: {\n        status: 'basic', // owner, premium, basic\n        limit: 30,\n        balance: 50,\n        chips: 100\n    },\n    \n    // Command Configuration\n    commands: {\n        prefix: '.',\n        limitCommands: ['profile', 'sticker', 's'] // Commands that require limits\n    },\n    \n    // Sticker Configuration\n    sticker: {\n        pack: 'seana bot',\n        author: 'pioo'\n    },\n    \n    // Status Levels\n    statusLevels: {\n        OWNER: 'owner',\n        PREMIUM: 'premium', \n        BASIC: 'basic'\n    },\n    \n    // Level System Configuration\n    levelSystem: {\n        // XP required per level (easy grinding - reduced requirements)\n        xpPerLevel: (level) => Math.floor(50 + (level * 25) + (level ** 1.2 * 15)),\n        \n        // Rank Configuration\n        ranks: [\n            { name: 'Luminary', minLevel: 1, maxLevel: 15, color: '#fbbf24', icon: '‚≠ê' },\n            { name: 'Sage', minLevel: 16, maxLevel: 30, color: '#10b981', icon: 'üåü' },\n            { name: 'Visionary', minLevel: 31, maxLevel: 50, color: '#3b82f6', icon: 'üîÆ' },\n            { name: 'Guardian', minLevel: 51, maxLevel: 75, color: '#8b5cf6', icon: 'üõ°Ô∏è' },\n            { name: 'Mastermind', minLevel: 76, maxLevel: 100, color: '#f59e0b', icon: 'üß†' },\n            { name: 'Zenith', minLevel: 101, maxLevel: 129, color: '#ef4444', icon: '‚ö°' },\n            { name: 'Celestial', minLevel: 130, maxLevel: 999, color: '#ec4899', icon: 'üëë' }\n        ],\n        \n        // XP Rewards\n        rewards: {\n            commandUse: 10,\n            dailyLogin: 50,\n            stickerCreate: 15,\n            profileView: 5\n        }\n    },\n    \n    // Messages Configuration\n    messages: {\n        // Success Messages\n        commandSuccess: '‚úÖ Command executed successfully!',\n        profileUpdated: '‚úÖ Profile updated successfully!',\n        \n        // Error Messages\n        commandNotFound: '‚ùå Command not found. Type .menu to see available commands.',\n        insufficientLimit: '‚ùå Insufficient limit! You need at least 1 limit to use this command.',\n        databaseError: '‚ùå Database error occurred. Please try again later.',\n        unauthorizedAccess: '‚ùå You are not authorized to use this command.',\n        \n        // Info Messages\n        welcomeMessage: 'üëã Welcome to Seana Bot! Type .menu to get started.',\n        \n        // Menu Message\n        menuMessage: `\n‚ï≠‚îÄ„Äå ü§ñ {botName} MENU „Äç\n‚îÇ\n‚îú‚îÄ„Äå üìã Basic Commands „Äç\n‚îÇ ‚Ä¢ .menu - Show this menu\n‚îÇ ‚Ä¢ .ping - Check bot response time\n‚îÇ ‚Ä¢ .profile - View your profile (1 limit)\n‚îÇ\n‚îú‚îÄ„Äå üé® Media Commands „Äç\n‚îÇ ‚Ä¢ .s/.sticker - Convert image to sticker (1 limit)\n‚îÇ\n‚îú‚îÄ„Äå ‚ÑπÔ∏è Bot Information „Äç\n‚îÇ ‚Ä¢ Bot Name: {botName}\n‚îÇ ‚Ä¢ Owner: @6285709557572\n‚îÇ ‚Ä¢ Status: Active\n‚îÇ\n‚ï∞‚îÄ„Äå üí° Note: Commands marked with limit cost will deduct from your available limits „Äç\n‚ï∞‚îÄ„Äå ‚≠ê Owner & Premium users have unlimited limits „Äç`,\n\n        // Profile Message Template\n        profileMessage: `\n‚îå‚îÄ„Äå User Info „Äç\n‚îÇ ‚Ä¢ Username: {username}\n‚îÇ ‚Ä¢ Tag: {tag}\n‚îÇ ‚Ä¢ Status: {status}\n‚îÇ ‚Ä¢ Limit: {limitDisplay}\n‚îÇ ‚Ä¢ Balance: {balance}\n‚îÇ ‚Ä¢ Chips: {chips}\n‚îÇ ‚Ä¢ Member since: {memberSince}\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`,\n        \n        // Ping Message\n        pingMessage: 'üèì Pong!  {responseTime}ms'\n    }\n};\n","size_bytes":3759},"database/announcements.js":{"content":"const Announcement = require('./models/Announcement');\n\n// Initialize announcements collection with sample data\nconst initAnnouncementsTable = async () => {\n    try {\n        console.log('‚úÖ Announcements collection initialized successfully');\n        \n        // Insert sample announcements if collection is empty\n        const count = await Announcement.countDocuments({});\n        \n        if (count === 0) {\n            await insertSampleAnnouncements();\n        }\n        \n    } catch (error) {\n        console.error('‚ùå Error initializing announcements collection:', error);\n    }\n};\n\n// Insert sample announcements\nconst insertSampleAnnouncements = async () => {\n    try {\n        const sampleAnnouncements = [\n            {\n                title: 'Welcome to Seana Bot!',\n                content: 'Bot WhatsApp canggih dengan berbagai fitur menarik seperti commands, sticker maker, dan banyak lagi. Nikmati pengalaman chatting yang lebih seru!',\n                author: '+6285709557572',\n                icon: 'üéâ'\n            },\n            {\n                title: 'Sticker Feature Available',\n                content: 'Fitur pembuatan sticker telah tersedia! Convert gambar menjadi sticker dengan mudah menggunakan command .s atau .sticker!',\n                author: '+6285709557572',\n                icon: 'üñºÔ∏è'\n            },\n            {\n                title: 'Bot Commands Updated',\n                content: 'Sistem command telah diperbarui dengan response time yang lebih cepat. Gunakan .menu untuk melihat semua command yang tersedia.',\n                author: '+6285709557572',\n                icon: '‚ö°'\n            }\n        ];\n        \n        await Announcement.insertMany(sampleAnnouncements);\n        \n        console.log('‚úÖ Sample announcements inserted successfully');\n    } catch (error) {\n        console.error('‚ùå Error inserting sample announcements:', error);\n    }\n};\n\n// Get recent announcements (limit for homepage)\nconst getRecentAnnouncements = async (limit = 3) => {\n    try {\n        return await Announcement.find({ isActive: true })\n            .sort({ createdAt: -1 })\n            .limit(limit)\n            .lean();\n    } catch (error) {\n        console.error('‚ùå Error fetching recent announcements:', error);\n        return [];\n    }\n};\n\n// Get all announcements (for news page)\nconst getAllAnnouncements = async () => {\n    try {\n        return await Announcement.find({ isActive: true })\n            .sort({ createdAt: -1 })\n            .lean();\n    } catch (error) {\n        console.error('‚ùå Error fetching all announcements:', error);\n        return [];\n    }\n};\n\n// Add new announcement\nconst addAnnouncement = async (title, content, author, icon = 'üì¢', category = 'pengumuman') => {\n    try {\n        const announcement = new Announcement({\n            title,\n            content,\n            author,\n            icon,\n            category\n        });\n        return await announcement.save();\n    } catch (error) {\n        console.error('‚ùå Error adding announcement:', error);\n        throw error;\n    }\n};\n\n// Update announcement\nconst updateAnnouncement = async (id, updateData) => {\n    try {\n        return await Announcement.findByIdAndUpdate(id, updateData, { new: true });\n    } catch (error) {\n        console.error('‚ùå Error updating announcement:', error);\n        throw error;\n    }\n};\n\n// Delete announcement\nconst deleteAnnouncement = async (id) => {\n    try {\n        await Announcement.findByIdAndUpdate(id, { isActive: false });\n        return true;\n    } catch (error) {\n        console.error('‚ùå Error deleting announcement:', error);\n        throw error;\n    }\n};\n\n// Format date for display\nconst formatDate = (dateString) => {\n    const date = new Date(dateString);\n    \n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n        return 'Tanggal tidak valid';\n    }\n    \n    const options = { \n        year: 'numeric', \n        month: 'short', \n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n        timeZone: 'Asia/Jakarta',\n        hour12: false\n    };\n    return date.toLocaleDateString('id-ID', options);\n};\n\nmodule.exports = {\n    initAnnouncementsTable,\n    getRecentAnnouncements,\n    getAllAnnouncements,\n    addAnnouncement,\n    updateAnnouncement,\n    deleteAnnouncement,\n    formatDate\n};","size_bytes":4335},"database/borders.js":{"content":"const mongoose = require('mongoose');\n\n// Border Schema\nconst borderSchema = new mongoose.Schema({\n    borderId: {\n        type: String,\n        required: true,\n        unique: true\n    },\n    name: {\n        type: String,\n        required: true\n    },\n    description: {\n        type: String,\n        default: ''\n    },\n    imageUrl: {\n        type: String,\n        required: true\n    },\n    rarity: {\n        type: String,\n        enum: ['common', 'rare', 'epic', 'legendary'],\n        default: 'common'\n    },\n    isActive: {\n        type: Boolean,\n        default: true\n    },\n    createdAt: {\n        type: Date,\n        default: Date.now\n    },\n    createdBy: {\n        type: String,\n        default: 'system'\n    }\n});\n\n// User Border Schema - tracks which borders users own and which they have equipped\nconst userBorderSchema = new mongoose.Schema({\n    userId: {\n        type: String,\n        required: true\n    },\n    ownedBorders: [{\n        borderId: String,\n        obtainedAt: {\n            type: Date,\n            default: Date.now\n        }\n    }],\n    equippedBorder: {\n        type: String,\n        default: null // null means no border equipped\n    },\n    updatedAt: {\n        type: Date,\n        default: Date.now\n    }\n});\n\nconst Border = mongoose.model('Border', borderSchema);\nconst UserBorder = mongoose.model('UserBorder', userBorderSchema);\n\n// Initialize borders table with default borders\nconst initBordersTable = async () => {\n    try {\n        console.log('üé® Initializing borders system...');\n        \n        // Check if borders already exist\n        const existingBorders = await Border.countDocuments();\n        if (existingBorders > 0) {\n            console.log('‚úÖ Borders system already initialized');\n            return;\n        }\n\n        // Create default borders\n        const defaultBorders = [\n            {\n                borderId: 'default',\n                name: 'Default',\n                description: 'Simple clean border',\n                imageUrl: '/borders/default.svg',\n                rarity: 'common'\n            },\n            {\n                borderId: 'gold-frame',\n                name: 'Gold Frame',\n                description: 'Elegant gold border frame',\n                imageUrl: '/borders/gold-frame.svg',\n                rarity: 'rare'\n            },\n            {\n                borderId: 'neon-glow',\n                name: 'Neon Glow',\n                description: 'Futuristic neon glow effect',\n                imageUrl: '/borders/neon-glow.svg',\n                rarity: 'epic'\n            },\n            {\n                borderId: 'diamond-luxury',\n                name: 'Diamond Luxury',\n                description: 'Premium diamond-studded border',\n                imageUrl: '/borders/diamond-luxury.svg',\n                rarity: 'legendary'\n            }\n        ];\n\n        await Border.insertMany(defaultBorders);\n        console.log('‚úÖ Default borders created successfully');\n        \n    } catch (error) {\n        console.error('‚ùå Error initializing borders system:', error.message);\n    }\n};\n\n// Get all active borders\nconst getAllBorders = async () => {\n    try {\n        return await Border.find({ isActive: true }).sort({ createdAt: -1 });\n    } catch (error) {\n        console.error('‚ùå Error fetching borders:', error.message);\n        return [];\n    }\n};\n\n// Get border by ID\nconst getBorderById = async (borderId) => {\n    try {\n        return await Border.findOne({ borderId, isActive: true });\n    } catch (error) {\n        console.error('‚ùå Error fetching border:', error.message);\n        return null;\n    }\n};\n\n// Create new border\nconst createBorder = async (borderData) => {\n    try {\n        const border = new Border(borderData);\n        await border.save();\n        console.log(`‚úÖ Border created: ${border.name}`);\n        return border;\n    } catch (error) {\n        console.error('‚ùå Error creating border:', error.message);\n        return null;\n    }\n};\n\n// Update border\nconst updateBorder = async (borderId, updateData) => {\n    try {\n        const border = await Border.findOneAndUpdate(\n            { borderId },\n            { ...updateData, updatedAt: new Date() },\n            { new: true }\n        );\n        console.log(`‚úÖ Border updated: ${borderId}`);\n        return border;\n    } catch (error) {\n        console.error('‚ùå Error updating border:', error.message);\n        return null;\n    }\n};\n\n// Delete border (soft delete)\nconst deleteBorder = async (borderId) => {\n    try {\n        const border = await Border.findOneAndUpdate(\n            { borderId },\n            { isActive: false },\n            { new: true }\n        );\n        console.log(`‚úÖ Border deleted: ${borderId}`);\n        return border;\n    } catch (error) {\n        console.error('‚ùå Error deleting border:', error.message);\n        return null;\n    }\n};\n\n// Get user's borders\nconst getUserBorders = async (userId) => {\n    try {\n        let userBorders = await UserBorder.findOne({ userId });\n        if (!userBorders) {\n            // Create default user borders entry with default border\n            userBorders = new UserBorder({\n                userId,\n                ownedBorders: [{ borderId: 'default' }],\n                equippedBorder: null\n            });\n            await userBorders.save();\n        }\n        \n        // Return the full user border document for API\n        return userBorders;\n    } catch (error) {\n        console.error('‚ùå Error fetching user borders:', error.message);\n        return { ownedBorders: [], equippedBorder: null };\n    }\n};\n\n// Add border to user\nconst addBorderToUser = async (userId, borderId) => {\n    try {\n        // Get or create user border document\n        let userBorderDoc = await UserBorder.findOne({ userId });\n        \n        if (!userBorderDoc) {\n            userBorderDoc = new UserBorder({\n                userId,\n                ownedBorders: [{ borderId: 'default' }],\n                equippedBorder: null\n            });\n        }\n        \n        // Check if user already owns this border\n        const alreadyOwns = userBorderDoc.ownedBorders.some(b => b.borderId === borderId);\n        if (alreadyOwns) {\n            console.log(`‚ö†Ô∏è User ${userId} already owns border ${borderId}`);\n            return { success: false, message: 'User already owns this border' };\n        }\n\n        // Add the border\n        userBorderDoc.ownedBorders.push({ borderId });\n        userBorderDoc.updatedAt = new Date();\n        await userBorderDoc.save();\n        \n        console.log(`‚úÖ Border ${borderId} added to user ${userId}. Total owned: ${userBorderDoc.ownedBorders.length}`);\n        return { success: true, message: 'Border added successfully' };\n    } catch (error) {\n        console.error('‚ùå Error adding border to user:', error.message);\n        return { success: false, message: 'Failed to add border: ' + error.message };\n    }\n};\n\n// Equip border for user\nconst equipBorder = async (userId, borderId) => {\n    try {\n        const userBorders = await getUserBorders(userId);\n        \n        // Check if user owns this border\n        const ownsBorder = userBorders.ownedBorders.some(b => b.borderId === borderId);\n        if (!ownsBorder && borderId !== null) {\n            return { success: false, message: 'User does not own this border' };\n        }\n\n        userBorders.equippedBorder = borderId;\n        userBorders.updatedAt = new Date();\n        await userBorders.save();\n        \n        console.log(`‚úÖ Border ${borderId} equipped for user ${userId}`);\n        return { success: true, message: 'Border equipped successfully' };\n    } catch (error) {\n        console.error('‚ùå Error equipping border:', error.message);\n        return { success: false, message: 'Failed to equip border' };\n    }\n};\n\n// Get user's equipped border\nconst getUserEquippedBorder = async (userId) => {\n    try {\n        const userBorders = await getUserBorders(userId);\n        if (!userBorders.equippedBorder) {\n            return null;\n        }\n        return await getBorderById(userBorders.equippedBorder);\n    } catch (error) {\n        console.error('‚ùå Error fetching equipped border:', error.message);\n        return null;\n    }\n};\n\nmodule.exports = {\n    Border,\n    UserBorder,\n    initBordersTable,\n    getAllBorders,\n    getBorderById,\n    createBorder,\n    updateBorder,\n    deleteBorder,\n    getUserBorders,\n    addBorderToUser,\n    equipBorder,\n    getUserEquippedBorder\n};","size_bytes":8454},"database/connection.js":{"content":"const mongoose = require('mongoose');\nconst config = require('../config/config');\n\nlet isConnected = false;\n\nconst connectDB = async () => {\n    if (isConnected) {\n        console.log('üì¶ Using existing MongoDB connection');\n        return;\n    }\n\n    try {\n        console.log('üîó Connecting to MongoDB...');\n        \n        const conn = await mongoose.connect(config.mongoURI, {\n            serverSelectionTimeoutMS: 10000,\n            maxPoolSize: 10,\n            bufferCommands: false\n        });\n\n        isConnected = true;\n        console.log(`‚úÖ MongoDB connected: ${conn.connection.host}`);\n\n        // Handle connection events\n        mongoose.connection.on('error', (error) => {\n            console.error('‚ùå MongoDB connection error:', error.message);\n            isConnected = false;\n        });\n\n        mongoose.connection.on('disconnected', () => {\n            console.log('‚ö†Ô∏è MongoDB disconnected');\n            isConnected = false;\n        });\n\n        mongoose.connection.on('reconnected', () => {\n            console.log('üîÑ MongoDB reconnected');\n            isConnected = true;\n        });\n\n    } catch (error) {\n        console.error('‚ùå MongoDB connection failed:', error.message);\n        process.exit(1);\n    }\n};\n\nmodule.exports = connectDB;\n","size_bytes":1283},"database/posts.js":{"content":"\nconst Post = require('./models/Post');\nconst connectDB = require('./connection');\n\n// Initialize posts collection\nconst initPostsTable = async () => {\n    try {\n        await connectDB();\n        console.log('‚úÖ Posts system initialized');\n    } catch (error) {\n        console.error('‚ùå Failed to initialize posts system:', error);\n        throw error;\n    }\n};\n\n// Get recent posts for social feed\nconst getRecentPosts = async (limit = 20) => {\n    try {\n        const posts = await Post.getRecentPosts(limit);\n        return posts;\n    } catch (error) {\n        console.error('‚ùå Error fetching recent posts:', error);\n        return [];\n    }\n};\n\n// Get posts by specific user\nconst getPostsByUser = async (userId, limit = 20) => {\n    try {\n        const posts = await Post.getPostsByUser(userId, limit);\n        return posts;\n    } catch (error) {\n        console.error('‚ùå Error fetching user posts:', error);\n        return [];\n    }\n};\n\n// Create new post\nconst createPost = async (userId, author, type, content, mediaUrl = '') => {\n    try {\n        const newPost = new Post({\n            userId,\n            author,\n            type,\n            content,\n            mediaUrl\n        });\n        \n        await newPost.save();\n        console.log('‚úÖ Post created successfully');\n        return newPost;\n    } catch (error) {\n        console.error('‚ùå Error creating post:', error);\n        throw error;\n    }\n};\n\n// Update post\nconst updatePost = async (postId, updates) => {\n    try {\n        const updatedPost = await Post.findByIdAndUpdate(\n            postId, \n            updates, \n            { new: true }\n        );\n        \n        if (!updatedPost) {\n            console.log('‚ö†Ô∏è Post not found for update');\n            return null;\n        }\n        \n        console.log('‚úÖ Post updated successfully');\n        return updatedPost;\n    } catch (error) {\n        console.error('‚ùå Error updating post:', error);\n        throw error;\n    }\n};\n\n// Delete post\nconst deletePost = async (postId) => {\n    try {\n        const deletedPost = await Post.findByIdAndDelete(postId);\n        \n        if (!deletedPost) {\n            console.log('‚ö†Ô∏è Post not found for deletion');\n            return false;\n        }\n        \n        console.log('‚úÖ Post deleted successfully');\n        return true;\n    } catch (error) {\n        console.error('‚ùå Error deleting post:', error);\n        throw error;\n    }\n};\n\n// Like post\nconst likePost = async (postId, userId) => {\n    try {\n        const post = await Post.findById(postId);\n        if (!post) {\n            return { success: false, message: 'Post not found' };\n        }\n        \n        const liked = post.addLike(userId);\n        if (liked) {\n            await post.save();\n            return { success: true, message: 'Post liked', likesCount: post.getLikesCount() };\n        } else {\n            return { success: false, message: 'Already liked' };\n        }\n    } catch (error) {\n        console.error('‚ùå Error liking post:', error);\n        throw error;\n    }\n};\n\n// Unlike post\nconst unlikePost = async (postId, userId) => {\n    try {\n        const post = await Post.findById(postId);\n        if (!post) {\n            return { success: false, message: 'Post not found' };\n        }\n        \n        const unliked = post.removeLike(userId);\n        if (unliked) {\n            await post.save();\n            return { success: true, message: 'Post unliked', likesCount: post.getLikesCount() };\n        } else {\n            return { success: false, message: 'Not liked yet' };\n        }\n    } catch (error) {\n        console.error('‚ùå Error unliking post:', error);\n        throw error;\n    }\n};\n\n// Add comment to post\nconst addComment = async (postId, userId, author, content) => {\n    try {\n        const post = await Post.findById(postId);\n        if (!post) {\n            return { success: false, message: 'Post not found' };\n        }\n        \n        post.addComment(userId, author, content);\n        await post.save();\n        \n        return { \n            success: true, \n            message: 'Comment added', \n            commentsCount: post.getCommentsCount() \n        };\n    } catch (error) {\n        console.error('‚ùå Error adding comment:', error);\n        throw error;\n    }\n};\n\nmodule.exports = {\n    initPostsTable,\n    getRecentPosts,\n    getPostsByUser,\n    createPost,\n    updatePost,\n    deletePost,\n    likePost,\n    unlikePost,\n    addComment\n};\n","size_bytes":4460},"database/shop.js":{"content":"\nconst mongoose = require('mongoose');\n\n// Shop Item Schema\nconst shopItemSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        required: true\n    },\n    description: {\n        type: String,\n        default: ''\n    },\n    category: {\n        type: String,\n        required: true,\n        enum: ['border', 'premium', 'booster', 'cosmetic']\n    },\n    price: {\n        type: Number,\n        required: true,\n        min: 0\n    },\n    priceType: {\n        type: String,\n        required: true,\n        enum: ['balance', 'chips']\n    },\n    stock: {\n        type: Number,\n        required: true,\n        min: 0,\n        default: 0\n    },\n    imageUrl: {\n        type: String,\n        default: ''\n    },\n    isActive: {\n        type: Boolean,\n        default: true\n    },\n    purchaseLimit: {\n        type: String,\n        enum: ['unlimited', 'once'],\n        default: 'unlimited'\n    },\n    createdAt: {\n        type: Date,\n        default: Date.now\n    },\n    createdBy: {\n        type: String,\n        default: 'system'\n    }\n});\n\n// Purchase History Schema\nconst purchaseHistorySchema = new mongoose.Schema({\n    userId: {\n        type: String,\n        required: true\n    },\n    itemId: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'ShopItem',\n        required: true\n    },\n    itemName: {\n        type: String,\n        required: true\n    },\n    price: {\n        type: Number,\n        required: true\n    },\n    priceType: {\n        type: String,\n        required: true\n    },\n    purchasedAt: {\n        type: Date,\n        default: Date.now\n    }\n});\n\nconst ShopItem = mongoose.model('ShopItem', shopItemSchema);\nconst PurchaseHistory = mongoose.model('PurchaseHistory', purchaseHistorySchema);\n\n// Initialize shop table\nconst initShopTable = async () => {\n    try {\n        console.log('üõí Initializing shop system...');\n        \n        // Check if shop items already exist\n        const existingItems = await ShopItem.countDocuments();\n        if (existingItems > 0) {\n            console.log('‚úÖ Shop system already initialized');\n            return;\n        }\n\n        // Create default shop items\n        const defaultItems = [\n            {\n                name: 'Gold Frame Border',\n                description: 'Elegant gold border frame for your profile',\n                category: 'border',\n                price: 5000,\n                priceType: 'balance',\n                stock: 50,\n                imageUrl: '/borders/gold-frame.svg'\n            },\n            {\n                name: 'Neon Glow Border',\n                description: 'Futuristic neon glow effect border',\n                category: 'border',\n                price: 2000,\n                priceType: 'chips',\n                stock: 30,\n                imageUrl: '/borders/neon-glow.svg'\n            },\n            {\n                name: 'Diamond Luxury Border',\n                description: 'Premium diamond-studded border',\n                category: 'border',\n                price: 10000,\n                priceType: 'chips',\n                stock: 10,\n                imageUrl: '/borders/diamond-luxury.svg'\n            }\n        ];\n        \n        await ShopItem.insertMany(defaultItems);\n        console.log('‚úÖ Default shop items created successfully');\n        \n    } catch (error) {\n        console.error('‚ùå Error initializing shop system:', error.message);\n    }\n};\n\n// Get all shop items\nconst getAllShopItems = async () => {\n    try {\n        return await ShopItem.find({ isActive: true }).sort({ createdAt: -1 });\n    } catch (error) {\n        console.error('‚ùå Error fetching shop items:', error.message);\n        return [];\n    }\n};\n\n// Get shop item by ID\nconst getShopItemById = async (itemId) => {\n    try {\n        return await ShopItem.findById(itemId);\n    } catch (error) {\n        console.error('‚ùå Error fetching shop item:', error.message);\n        return null;\n    }\n};\n\n// Create new shop item\nconst createShopItem = async (itemData) => {\n    try {\n        const newItem = new ShopItem(itemData);\n        await newItem.save();\n        console.log(`‚úÖ Shop item created: ${newItem.name}`);\n        return newItem;\n    } catch (error) {\n        console.error('‚ùå Error creating shop item:', error.message);\n        return null;\n    }\n};\n\n// Update shop item\nconst updateShopItem = async (itemId, updateData) => {\n    try {\n        const updatedItem = await ShopItem.findByIdAndUpdate(\n            itemId, \n            updateData, \n            { new: true, runValidators: true }\n        );\n        \n        if (updatedItem) {\n            console.log(`‚úÖ Shop item updated: ${updatedItem.name}`);\n        }\n        \n        return updatedItem;\n    } catch (error) {\n        console.error('‚ùå Error updating shop item:', error.message);\n        return null;\n    }\n};\n\n// Delete shop item\nconst deleteShopItem = async (itemId) => {\n    try {\n        const deletedItem = await ShopItem.findByIdAndUpdate(\n            itemId,\n            { isActive: false },\n            { new: true }\n        );\n        \n        if (deletedItem) {\n            console.log(`‚úÖ Shop item deleted: ${deletedItem.name}`);\n        }\n        \n        return deletedItem;\n    } catch (error) {\n        console.error('‚ùå Error deleting shop item:', error.message);\n        return null;\n    }\n};\n\n// Purchase item\nconst purchaseItem = async (userId, itemId) => {\n    try {\n        const item = await getShopItemById(itemId);\n        if (!item) {\n            return { success: false, message: 'Item tidak ditemukan' };\n        }\n\n        if (item.stock <= 0) {\n            return { success: false, message: 'Item sudah habis' };\n        }\n\n        // Get user data\n        const { getUser, updateUser } = require('../utils/userUtils');\n        const user = await getUser(userId);\n        \n        if (!user) {\n            return { success: false, message: 'User tidak ditemukan' };\n        }\n\n        // Check if item is one-time purchase and user already bought it\n        if (item.purchaseLimit === 'once') {\n            const existingPurchase = await PurchaseHistory.findOne({ userId, itemId });\n            if (existingPurchase) {\n                return { success: false, message: 'Item ini hanya bisa dibeli sekali per akun' };\n            }\n        }\n\n        // Check if user has enough balance/chips\n        const userAmount = item.priceType === 'balance' ? user.balance : user.chips;\n        if (userAmount < item.price) {\n            return { success: false, message: `${item.priceType === 'balance' ? 'Balance' : 'Chips'} tidak mencukupi` };\n        }\n\n        // Deduct user balance/chips\n        const updateData = {};\n        if (item.priceType === 'balance') {\n            updateData.balance = user.balance - item.price;\n        } else {\n            updateData.chips = user.chips - item.price;\n        }\n\n        await updateUser(userId, updateData);\n\n        // Reduce item stock\n        await updateShopItem(itemId, { stock: item.stock - 1 });\n\n        // Add item to user if it's a border\n        if (item.category === 'border') {\n            const { addBorderToUser } = require('./borders');\n            // Create proper border ID mapping\n            let borderId;\n            if (item.name.toLowerCase().includes('gold')) {\n                borderId = 'gold-frame';\n            } else if (item.name.toLowerCase().includes('neon')) {\n                borderId = 'neon-glow';\n            } else if (item.name.toLowerCase().includes('diamond')) {\n                borderId = 'diamond-luxury';\n            } else {\n                // Create ID from name\n                borderId = item.name.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n            }\n            \n            console.log(`üõí Adding border to user ${userId}:`, {\n                itemName: item.name,\n                borderId: borderId,\n                category: item.category\n            });\n            \n            const borderResult = await addBorderToUser(userId, borderId);\n            console.log(`üõí Border assignment result for ${userId}:`, borderResult);\n            \n            if (!borderResult.success) {\n                console.error(`‚ùå Failed to add border ${borderId} to user ${userId}:`, borderResult.message);\n            } else {\n                console.log(`‚úÖ Successfully added border ${borderId} to user ${userId}`);\n            }\n        }\n\n        // Record purchase history\n        const purchase = new PurchaseHistory({\n            userId,\n            itemId,\n            itemName: item.name,\n            price: item.price,\n            priceType: item.priceType\n        });\n        \n        await purchase.save();\n\n        console.log(`‚úÖ Item purchased: ${item.name} by ${userId}`);\n        \n        return { \n            success: true, \n            message: 'Item berhasil dibeli!',\n            item: item,\n            purchase: purchase\n        };\n        \n    } catch (error) {\n        console.error('‚ùå Error purchasing item:', error.message);\n        return { success: false, message: 'Terjadi kesalahan saat membeli item' };\n    }\n};\n\n// Get user purchase history\nconst getUserPurchaseHistory = async (userId) => {\n    try {\n        return await PurchaseHistory.find({ userId }).sort({ purchasedAt: -1 });\n    } catch (error) {\n        console.error('‚ùå Error fetching purchase history:', error.message);\n        return [];\n    }\n};\n\nmodule.exports = {\n    ShopItem,\n    PurchaseHistory,\n    initShopTable,\n    getAllShopItems,\n    getShopItemById,\n    createShopItem,\n    updateShopItem,\n    deleteShopItem,\n    purchaseItem,\n    getUserPurchaseHistory\n};\n","size_bytes":9615},"handlers/commandHandler.js":{"content":"const config = require('../config/config');\nconst { getUser, updateUserActivity } = require('../utils/userUtils');\n\n// Import all commands\nconst menuCommand = require('../commands/menu');\nconst pingCommand = require('../commands/ping');\nconst profileCommand = require('../commands/profile');\nconst stickerCommand = require('../commands/sticker');\n\n// Command registry\nconst commands = {\n    'menu': menuCommand,\n    'ping': pingCommand,\n    'profile': profileCommand,\n    'sticker': stickerCommand,\n    's': stickerCommand\n};\n\nconst commandHandler = async (sock, from, sender, commandName, args, message) => {\n    try {\n        // Check if command exists\n        const command = commands[commandName];\n        if (!command) {\n            await sock.sendMessage(from, { \n                text: config.messages.commandNotFound \n            });\n            return;\n        }\n        \n        console.log(`üéØ Executing command: ${commandName} for user: ${sender}`);\n        \n        // Get user data for permission checks\n        const user = await getUser(sender);\n        if (!user) {\n            await sock.sendMessage(from, { \n                text: config.messages.databaseError \n            });\n            return;\n        }\n        \n        // Check if command requires limits\n        const isLimitCommand = config.commands.limitCommands.includes(commandName);\n        if (isLimitCommand || command.requiresLimit) {\n            const limitCost = command.limitCost || 1;\n            \n            // Owner and premium users have unlimited limits\n            if (!user.hasUnlimitedLimits() && user.limit < limitCost) {\n                await sock.sendMessage(from, { \n                    text: config.messages.insufficientLimit \n                });\n                return;\n            }\n        }\n        \n        // Execute the command\n        const success = await command.execute(sock, from, sender, args, message);\n        \n        if (success) {\n            console.log(`‚úÖ Command ${commandName} executed successfully`);\n            \n            // Update user activity and award XP\n            const activityResult = await updateUserActivity(sender, 'commandUse');\n            \n            // Send level up notification if user leveled up\n            if (activityResult && activityResult.leveledUp) {\n                const rank = activityResult.currentRank;\n                const levelUpMessage = `\nüéâ *LEVEL UP!* üéâ\n\n${rank.icon} **${user.username}** has reached Level **${activityResult.newLevel}**!\nüìà Rank: **${rank.name}**\n‚ö° XP Gained: +${activityResult.xpGained}\n\nKeep using commands to earn more XP! üöÄ`;\n                \n                setTimeout(() => {\n                    sock.sendMessage(from, { text: levelUpMessage });\n                }, 1000);\n            }\n        } else {\n            console.log(`‚ùå Command ${commandName} failed to execute`);\n        }\n        \n    } catch (error) {\n        console.error(`‚ùå Error in command handler for ${commandName}:`, error.message);\n        await sock.sendMessage(from, { \n            text: config.messages.databaseError \n        });\n    }\n};\n\nmodule.exports = commandHandler;\n","size_bytes":3156},"public/dashboard.css":{"content":"/* Dashboard and Page Styles */\n\n/* Main Content Layout */\n.main-content {\n    padding-top: 70px; /* Desktop nav height */\n    min-height: 100vh;\n    background: linear-gradient(135deg, #1e1e1e, #2d2d2d);\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 2rem;\n}\n\n/* Page Headers */\n.page-header {\n    text-align: center;\n    margin-bottom: 3rem;\n}\n\n.page-title {\n    font-size: 2.5rem;\n    font-weight: 700;\n    background: linear-gradient(45deg, #ffffff, #e0e0e0);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n    margin-bottom: 0.5rem;\n}\n\n.page-subtitle {\n    color: #a0a0a0;\n    font-size: 1.1rem;\n    max-width: 600px;\n    margin: 0 auto;\n}\n\n/* Welcome Section */\n.welcome-section {\n    margin-bottom: 1.5rem;\n}\n\n.welcome-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 20px;\n    padding: 2rem;\n    text-align: center;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n}\n\n.welcome-header {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 1rem;\n}\n\n.welcome-title {\n    font-size: 2rem;\n    font-weight: 700;\n    margin: 1rem 0;\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.welcome-subtitle {\n    color: #a0a0a0;\n    font-size: 1rem;\n    margin-bottom: 1.5rem;\n}\n\n/* User Info Section */\n.user-info-section {\n    margin-bottom: 1.5rem;\n}\n\n.user-info-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 15px;\n    padding: 1.5rem;\n    border: 1px solid rgba(99, 102, 241, 0.2);\n    backdrop-filter: blur(10px);\n}\n\n.section-title {\n    color: #6366f1;\n    font-size: 1.25rem;\n    font-weight: 600;\n    margin-bottom: 1rem;\n    text-align: center;\n}\n\n.user-info-card h3 {\n    color: #ffffff;\n    margin-bottom: 1.5rem;\n    font-size: 1.25rem;\n}\n\n.user-stats {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 1rem;\n}\n\n@media (max-width: 768px) {\n    .user-stats {\n        grid-template-columns: 1fr;\n    }\n}\n\n.stat-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 1rem;\n    background: rgba(30, 30, 30, 0.8);\n    border-radius: 12px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    transition: all 0.3s ease;\n}\n\n.stat-item:hover {\n    transform: translateY(-2px);\n    border-color: rgba(99, 102, 241, 0.3);\n    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);\n}\n\n.stat-label {\n    color: #a0a0a0;\n    font-weight: 500;\n}\n\n.stat-value {\n    color: #ffffff;\n    font-weight: 600;\n}\n\n.status-owner {\n    color: #fbbf24 !important;\n}\n\n.status-premium {\n    color: #8b5cf6 !important;\n}\n\n.status-basic {\n    color: #6b7280 !important;\n}\n\n/* News Section */\n.news-section {\n    margin-bottom: 2rem;\n}\n\n.section-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 2rem;\n}\n\n.section-header h2 {\n    color: #ffffff;\n    font-size: 1.5rem;\n    font-weight: 600;\n}\n\n.view-all {\n    color: #6366f1;\n    text-decoration: none;\n    font-weight: 500;\n    transition: color 0.3s ease;\n}\n\n.view-all:hover {\n    color: #8b5cf6;\n}\n\n/* News Grid */\n.news-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));\n    gap: 1.5rem;\n}\n\n.news-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 15px;\n    padding: 1.5rem;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n    transition: all 0.3s ease;\n}\n\n.news-card:hover {\n    transform: translateY(-2px);\n    border-color: rgba(99, 102, 241, 0.3);\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n}\n\n.news-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 1rem;\n}\n\n.news-tag {\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    color: white;\n    padding: 0.25rem 0.75rem;\n    border-radius: 20px;\n    font-size: 0.8rem;\n    font-weight: 600;\n}\n\n.news-tag.featured {\n    background: linear-gradient(45deg, #fbbf24, #f59e0b);\n}\n\n.news-date {\n    color: #a0a0a0;\n    font-size: 0.85rem;\n}\n\n.news-title {\n    color: #ffffff;\n    font-size: 1.125rem;\n    font-weight: 600;\n    margin-bottom: 0.75rem;\n    line-height: 1.4;\n}\n\n.news-excerpt, .news-content {\n    color: #d1d5db;\n    line-height: 1.6;\n    margin-bottom: 1rem;\n}\n\n.news-author {\n    color: #6366f1;\n    font-size: 0.85rem;\n    font-weight: 500;\n}\n\n/* Featured News */\n.featured-news {\n    margin-bottom: 3rem;\n}\n\n.featured-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 20px;\n    padding: 2.5rem;\n    border: 1px solid rgba(251, 191, 36, 0.2);\n    backdrop-filter: blur(10px);\n}\n\n.featured-card .news-title {\n    font-size: 1.75rem;\n    margin-bottom: 1.5rem;\n}\n\n/* Quick Actions */\n.quick-actions {\n    margin-bottom: 2rem;\n}\n\n.actions-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 1rem;\n}\n\n.action-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 15px;\n    padding: 1.5rem;\n    text-align: center;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n    text-decoration: none;\n    color: inherit;\n    transition: all 0.3s ease;\n}\n\n.action-card:hover {\n    transform: translateY(-5px);\n    border-color: rgba(99, 102, 241, 0.3);\n    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);\n}\n\n.action-icon {\n    font-size: 2rem;\n    margin-bottom: 0.75rem;\n}\n\n.action-card h3 {\n    color: #ffffff;\n    font-size: 1.125rem;\n    font-weight: 600;\n    margin-bottom: 0.5rem;\n}\n\n.action-card p {\n    color: #a0a0a0;\n    font-size: 0.95rem;\n}\n\n/* Mobile Bottom Padding */\n.mobile-bottom-padding {\n    height: 80px; /* Bottom nav height on mobile */\n    display: none;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .main-content {\n        padding-top: 60px; /* Mobile top nav height */\n    }\n    \n    .container {\n        padding: 1rem;\n    }\n    \n    .welcome-card {\n        padding: 2rem 1.5rem;\n    }\n    \n    .welcome-title {\n        font-size: 2rem;\n    }\n    \n    .page-title {\n        font-size: 2rem;\n    }\n    \n    .news-grid {\n        grid-template-columns: 1fr;\n        gap: 1rem;\n    }\n    \n    .actions-grid {\n        grid-template-columns: repeat(2, 1fr);\n        gap: 1rem;\n    }\n    \n    .user-stats {\n        grid-template-columns: 1fr;\n    }\n    \n    .featured-card {\n        padding: 1.5rem;\n    }\n    \n    .featured-card .news-title {\n        font-size: 1.375rem;\n    }\n    \n    .mobile-bottom-padding {\n        display: block;\n    }\n}\n\n@media (max-width: 480px) {\n    .container {\n        padding: 0.75rem;\n    }\n    \n    .welcome-card {\n        padding: 1.5rem 1rem;\n    }\n    \n    .welcome-title {\n        font-size: 1.75rem;\n    }\n    \n    .page-title {\n        font-size: 1.75rem;\n    }\n    \n    .actions-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .action-card {\n        padding: 1.5rem;\n    }\n    \n    .news-card {\n        padding: 1.25rem;\n    }\n    \n    .featured-card {\n        padding: 1.25rem;\n    }\n    \n    .section-header {\n        flex-direction: column;\n        align-items: flex-start;\n        gap: 0.5rem;\n    }\n}\n\n/* Balance Display */\n.balance-display {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n    background: rgba(40, 40, 40, 0.95);\n    padding: 1rem 2rem;\n    border-radius: 50px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin-top: 1rem;\n    flex-wrap: wrap;\n}\n\n.balance-separator {\n    color: rgba(255, 255, 255, 0.3);\n    margin: 0 0.5rem;\n}\n\n.balance-icon {\n    font-size: 1.25rem;\n}\n\n.balance-amount {\n    color: #6366f1;\n    font-weight: 700;\n    font-size: 1.125rem;\n}","size_bytes":7765},"public/navigation.css":{"content":"/* Navigation Styles */\n\n/* Desktop Navigation */\n.desktop-nav {\n    position: sticky;\n    top: 0;\n    z-index: 1000;\n    background: rgba(30, 30, 30, 0.95);\n    backdrop-filter: blur(10px);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    padding: 0 2rem;\n}\n\n.nav-container {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    max-width: 1200px;\n    margin: 0 auto;\n    height: 70px;\n}\n\n.nav-brand {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.lightning-bolt {\n    font-size: 1.5rem;\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.brand-name {\n    font-size: 1.25rem;\n    font-weight: 700;\n    color: #ffffff;\n}\n\n.nav-menu {\n    display: flex;\n    align-items: center;\n    gap: 2rem;\n}\n\n.nav-link {\n    color: #a0a0a0;\n    text-decoration: none;\n    font-weight: 500;\n    padding: 0.5rem 1rem;\n    border-radius: 8px;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.nav-link:hover,\n.nav-link.active {\n    color: #ffffff;\n    background: rgba(99, 102, 241, 0.1);\n}\n\n.nav-link.active::after {\n    content: '';\n    position: absolute;\n    bottom: -2px;\n    left: 50%;\n    transform: translateX(-50%);\n    width: 20px;\n    height: 2px;\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    border-radius: 1px;\n}\n\n/* Dropdown Styles */\n.dropdown {\n    position: relative;\n}\n\n.dropdown-toggle {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    background: none;\n    border: none;\n    cursor: pointer;\n}\n\n.chevron-down {\n    font-size: 0.75rem;\n    transition: transform 0.3s ease;\n}\n\n.dropdown:hover .chevron-down {\n    transform: rotate(180deg);\n}\n\n.dropdown-menu {\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%) translateY(-10px);\n    width: 650px;\n    max-width: 90vw;\n    background: rgba(40, 40, 40, 0.98);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 12px;\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);\n    backdrop-filter: blur(10px);\n    opacity: 0;\n    visibility: hidden;\n    transition: all 0.3s ease;\n    z-index: 1001;\n    margin-top: 0.5rem;\n    padding: 1.5rem;\n}\n\n.dropdown:hover .dropdown-menu {\n    opacity: 1;\n    visibility: visible;\n    transform: translateX(-50%) translateY(0);\n}\n\n/* Grid Dropdown Styles */\n.dropdown-grid {\n    display: grid;\n    grid-template-columns: repeat(4, 1fr);\n    gap: 2rem;\n    width: 100%;\n}\n\n.dropdown-section {\n    display: flex;\n    flex-direction: column;\n    min-width: 140px;\n}\n\n.dropdown-label {\n    color: #6366f1;\n    font-size: 0.825rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    padding: 0 0 0.5rem 0;\n    margin-bottom: 0.75rem;\n    border-bottom: 1px solid rgba(99, 102, 241, 0.2);\n    text-align: center;\n}\n\n.dropdown-items {\n    display: flex;\n    flex-direction: column;\n    gap: 0.25rem;\n}\n\n.dropdown-item {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    color: #a0a0a0;\n    text-decoration: none;\n    padding: 0.75rem 0.5rem;\n    border-radius: 8px;\n    transition: all 0.2s ease;\n    font-size: 0.875rem;\n    white-space: nowrap;\n}\n\n.dropdown-item:hover {\n    color: #ffffff;\n    background: rgba(99, 102, 241, 0.1);\n}\n\n.dropdown-item-icon {\n    font-size: 0.9rem;\n    width: 16px;\n    text-align: center;\n}\n\n/* Currency Display */\n.nav-currency {\n    display: flex;\n    gap: 1rem;\n}\n\n.currency-item {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    background: rgba(40, 40, 40, 0.8);\n    padding: 0.5rem 1rem;\n    border-radius: 20px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.currency-icon {\n    font-size: 1rem;\n}\n\n.currency-value {\n    color: #ffffff;\n    font-weight: 600;\n    font-size: 0.9rem;\n}\n\n/* Mobile Navigation */\n.mobile-nav {\n    display: none;\n}\n\n.mobile-top-nav {\n    position: sticky;\n    top: 0;\n    z-index: 1000;\n    background: rgba(30, 30, 30, 0.95);\n    backdrop-filter: blur(10px);\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    padding: 0 1rem;\n}\n\n.mobile-top-nav .nav-container {\n    height: 60px;\n    justify-content: space-between;\n}\n\n.squad-name {\n    color: #a0a0a0;\n    font-size: 0.9rem;\n    font-weight: 500;\n}\n\n.mobile-bottom-nav {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 1000;\n    background: rgba(30, 30, 30, 0.95);\n    backdrop-filter: blur(10px);\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\n    display: flex;\n    padding: 0.5rem 0;\n}\n\n.mobile-bottom-nav .nav-item {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: 0.25rem;\n    color: #a0a0a0;\n    text-decoration: none;\n    padding: 0.5rem;\n    transition: all 0.3s ease;\n    background: none;\n    border: none;\n    cursor: pointer;\n}\n\n.mobile-bottom-nav .nav-item:hover,\n.mobile-bottom-nav .nav-item.active {\n    color: #6366f1;\n}\n\n.nav-icon {\n    font-size: 1.25rem;\n}\n\n.nav-text {\n    font-size: 0.75rem;\n    font-weight: 500;\n}\n\n/* Bottom Sheet */\n.bottom-sheet-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.5);\n    z-index: 1998;\n    opacity: 0;\n    visibility: hidden;\n    transition: all 0.3s ease;\n}\n\n.bottom-sheet-overlay.active {\n    opacity: 1;\n    visibility: visible;\n}\n\n.bottom-sheet {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: 1999;\n    background: rgba(30, 30, 30, 0.98);\n    backdrop-filter: blur(10px);\n    border-top-left-radius: 20px;\n    border-top-right-radius: 20px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    max-height: 70vh;\n    transform: translateY(100%);\n    transition: transform 0.3s ease;\n}\n\n.bottom-sheet.active {\n    transform: translateY(0);\n}\n\n.sheet-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 1rem;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    position: relative;\n}\n\n.sheet-handle {\n    position: absolute;\n    top: -10px;\n    left: 50%;\n    transform: translateX(-50%);\n    width: 40px;\n    height: 4px;\n    background: rgba(255, 255, 255, 0.3);\n    border-radius: 2px;\n}\n\n.sheet-header h3 {\n    color: #ffffff;\n    font-size: 1.125rem;\n    font-weight: 600;\n    margin: 0;\n}\n\n.sheet-close {\n    background: none;\n    border: none;\n    color: #a0a0a0;\n    font-size: 1.25rem;\n    cursor: pointer;\n    padding: 0.25rem;\n    border-radius: 4px;\n    transition: all 0.3s ease;\n}\n\n.sheet-close:hover {\n    color: #ffffff;\n    background: rgba(255, 255, 255, 0.1);\n}\n\n.sheet-content {\n    padding: 1rem;\n    max-height: calc(70vh - 80px);\n    overflow-y: auto;\n}\n\n.sheet-section {\n    margin-bottom: 1.5rem;\n}\n\n.sheet-section:last-child {\n    margin-bottom: 0;\n}\n\n.section-label {\n    color: #6366f1;\n    font-size: 0.875rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    margin-bottom: 0.75rem;\n}\n\n.sheet-item {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    color: #a0a0a0;\n    text-decoration: none;\n    padding: 1rem;\n    border-radius: 12px;\n    transition: all 0.3s ease;\n    margin-bottom: 0.5rem;\n}\n\n.sheet-item:hover {\n    color: #ffffff;\n    background: rgba(99, 102, 241, 0.1);\n}\n\n.item-icon {\n    font-size: 1.25rem;\n    width: 24px;\n    text-align: center;\n}\n\n.item-text {\n    font-weight: 500;\n}\n\n/* Body modifications when sheet is open */\nbody.sheet-open {\n    overflow: hidden;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .desktop-nav {\n        display: none;\n    }\n    \n    .mobile-nav {\n        display: block;\n    }\n    \n    .mobile-top-nav .nav-currency {\n        gap: 0.5rem;\n    }\n    \n    .mobile-top-nav .currency-item {\n        padding: 0.25rem 0.75rem;\n        font-size: 0.85rem;\n    }\n    \n    .squad-name {\n        display: none;\n    }\n}\n\n@media (max-width: 480px) {\n    .mobile-top-nav .nav-container {\n        padding: 0 0.5rem;\n    }\n    \n    .mobile-top-nav .currency-item {\n        padding: 0.25rem 0.5rem;\n    }\n    \n    .currency-value {\n        font-size: 0.8rem;\n    }\n}\n\n/* Tablet adjustments */\n@media (min-width: 769px) and (max-width: 1024px) {\n    .nav-container {\n        padding: 0 1rem;\n    }\n    \n    .nav-menu {\n        gap: 1.5rem;\n    }\n}","size_bytes":8306},"public/styles.css":{"content":"\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: linear-gradient(135deg, #1e1e1e, #2d2d2d);\n    color: #ffffff;\n    min-height: 100vh;\n    line-height: 1.6;\n}\n\n.container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    padding: 20px;\n}\n\n.main-card, .login-card, .qr-card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 20px;\n    padding: 40px;\n    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);\n    text-align: center;\n    max-width: 500px;\n    width: 100%;\n    backdrop-filter: blur(10px);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.logo {\n    margin-bottom: 20px;\n}\n\n.lightning-bolt {\n    font-size: 3rem;\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n    filter: drop-shadow(0 0 10px rgba(139, 92, 246, 0.3));\n}\n\n.brand-title, .login-title, .qr-title {\n    font-size: 2.5rem;\n    font-weight: 700;\n    margin-bottom: 10px;\n    background: linear-gradient(45deg, #ffffff, #e0e0e0);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.brand-subtitle, .login-subtitle, .qr-subtitle {\n    color: #a0a0a0;\n    margin-bottom: 30px;\n    font-size: 1.1rem;\n}\n\n.features {\n    margin: 30px 0;\n    text-align: left;\n}\n\n.feature-item {\n    display: flex;\n    align-items: center;\n    margin-bottom: 15px;\n    padding: 10px;\n    border-radius: 10px;\n    background: rgba(99, 102, 241, 0.1);\n    border: 1px solid rgba(99, 102, 241, 0.2);\n}\n\n.checkmark {\n    color: #10b981;\n    font-weight: bold;\n    margin-right: 15px;\n    font-size: 1.1rem;\n}\n\n.buttons {\n    display: flex;\n    flex-direction: column;\n    gap: 15px;\n    margin-top: 30px;\n}\n\n.btn {\n    padding: 15px 30px;\n    border: none;\n    border-radius: 12px;\n    font-size: 1rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    text-decoration: none;\n    display: inline-block;\n    text-align: center;\n}\n\n.btn-primary {\n    background: linear-gradient(45deg, #6366f1, #8b5cf6);\n    color: white;\n    box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);\n}\n\n.btn-primary:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);\n}\n\n.btn-secondary {\n    background: rgba(55, 65, 81, 0.8);\n    color: white;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.btn-secondary:hover {\n    background: rgba(75, 85, 99, 0.9);\n    transform: translateY(-2px);\n}\n\n.btn-full {\n    width: 100%;\n}\n\n.btn-small {\n    padding: 8px 16px;\n    font-size: 0.9rem;\n}\n\n.btn-danger {\n    background: linear-gradient(45deg, #ef4444, #dc2626);\n    color: white;\n}\n\n.login-form {\n    margin-top: 20px;\n}\n\n.input-group {\n    margin-bottom: 20px;\n    text-align: left;\n}\n\n.input-group label {\n    display: block;\n    margin-bottom: 8px;\n    color: #e0e0e0;\n    font-weight: 500;\n}\n\n.input-group input {\n    width: 100%;\n    padding: 15px;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    border-radius: 10px;\n    background: rgba(30, 30, 30, 0.8);\n    color: white;\n    font-size: 1rem;\n    transition: border-color 0.3s ease;\n}\n\n.input-group input:focus {\n    outline: none;\n    border-color: #6366f1;\n    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);\n}\n\n.input-group input::placeholder {\n    color: #888;\n}\n\n.code-input {\n    text-align: center;\n    font-size: 1.5rem;\n    letter-spacing: 0.5rem;\n    font-weight: bold;\n}\n\n.error-message {\n    background: rgba(239, 68, 68, 0.1);\n    border: 1px solid rgba(239, 68, 68, 0.3);\n    color: #fca5a5;\n    padding: 12px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    font-size: 0.9rem;\n}\n\n.success-message {\n    background: rgba(34, 197, 94, 0.1);\n    border: 1px solid rgba(34, 197, 94, 0.3);\n    color: #86efac;\n    padding: 20px;\n    border-radius: 12px;\n    margin: 20px 0;\n    font-size: 0.9rem;\n    text-align: center;\n}\n\n.success-message h3 {\n    color: #10b981;\n    margin-bottom: 10px;\n    font-size: 1.2rem;\n}\n\n.info-text {\n    color: #a0a0a0;\n    font-size: 0.9rem;\n    margin-top: 15px;\n}\n\n.back-link {\n    margin-top: 20px;\n}\n\n.back-link a {\n    color: #6366f1;\n    text-decoration: none;\n    font-size: 0.9rem;\n}\n\n.back-link a:hover {\n    text-decoration: underline;\n}\n\n/* QR Code Styles */\n.qr-container {\n    margin: 30px 0;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 15px;\n    border: 2px dashed rgba(255, 255, 255, 0.2);\n}\n\n.qr-placeholder {\n    width: 300px;\n    height: 300px;\n    margin: 0 auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: rgba(255, 255, 255, 0.1);\n    border-radius: 10px;\n}\n\n.qr-loading {\n    text-align: center;\n    color: #a0a0a0;\n}\n\n.spinner {\n    width: 40px;\n    height: 40px;\n    border: 4px solid rgba(255, 255, 255, 0.1);\n    border-left: 4px solid #6366f1;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n    margin: 0 auto 15px;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n.qr-instructions {\n    text-align: left;\n    margin: 30px 0;\n    background: rgba(99, 102, 241, 0.1);\n    padding: 20px;\n    border-radius: 10px;\n    border: 1px solid rgba(99, 102, 241, 0.2);\n}\n\n.qr-instructions h3 {\n    color: #e0e0e0;\n    margin-bottom: 15px;\n}\n\n.qr-instructions ol {\n    color: #b0b0b0;\n    padding-left: 20px;\n}\n\n.qr-instructions li {\n    margin-bottom: 8px;\n}\n\n/* Dashboard Styles */\n.dashboard-container {\n    min-height: 100vh;\n    background: linear-gradient(135deg, #1e1e1e, #2d2d2d);\n}\n\n.dashboard-header {\n    background: rgba(40, 40, 40, 0.95);\n    padding: 20px 30px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n}\n\n.header-left {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.header-left h1 {\n    font-size: 1.5rem;\n    font-weight: 600;\n}\n\n.header-left .logo {\n    margin: 0;\n}\n\n.header-left .lightning-bolt {\n    font-size: 1.5rem;\n}\n\n.header-right {\n    display: flex;\n    align-items: center;\n    gap: 20px;\n}\n\n.user-info {\n    color: #a0a0a0;\n    font-size: 0.9rem;\n}\n\n.dashboard-main {\n    padding: 15px;\n}\n\n.dashboard-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 12px;\n    max-width: 800px;\n    margin: 0 auto;\n}\n\n.card {\n    background: rgba(40, 40, 40, 0.95);\n    border-radius: 10px;\n    padding: 15px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n}\n\n.card h3 {\n    margin-bottom: 10px;\n    color: #e0e0e0;\n    font-size: 1rem;\n}\n\n.status-indicator {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.status-dot {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    background: #ef4444;\n}\n\n.status-dot.active {\n    background: #10b981;\n    box-shadow: 0 0 10px rgba(16, 185, 129, 0.3);\n}\n\n.user-stats {\n    display: flex;\n    flex-direction: column;\n    gap: 6px;\n}\n\n.stat {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 6px 0;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.stat:last-child {\n    border-bottom: none;\n}\n\n.stat-label {\n    color: #a0a0a0;\n    font-size: 0.8rem;\n}\n\n.stat-value {\n    color: #e0e0e0;\n    font-weight: 600;\n    font-size: 0.9rem;\n}\n\n.action-buttons {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .main-card, .login-card, .qr-card {\n        padding: 30px 20px;\n        margin: 10px;\n    }\n    \n    .brand-title, .login-title, .qr-title {\n        font-size: 2rem;\n    }\n    \n    .dashboard-header {\n        flex-direction: column;\n        gap: 15px;\n        text-align: center;\n    }\n    \n    .header-right {\n        flex-direction: column;\n        gap: 10px;\n    }\n    \n    .dashboard-main {\n        padding: 20px 15px;\n    }\n    \n    .dashboard-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .qr-placeholder {\n        width: 250px;\n        height: 250px;\n    }\n}\n\n@media (max-width: 480px) {\n    .buttons {\n        gap: 10px;\n    }\n    \n    .btn {\n        padding: 12px 20px;\n        font-size: 0.9rem;\n    }\n    \n    .features {\n        margin: 20px 0;\n    }\n    \n    .feature-item {\n        padding: 8px;\n        margin-bottom: 10px;\n    }\n}\n","size_bytes":8511},"server/db.ts":{"content":"import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport ws from \"ws\";\nimport * as schema from \"@shared/schema\";\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle({ client: pool, schema });\n","size_bytes":483},"utils/levelUtils.js":{"content":"const config = require('../config/config');\n\n/**\n * Calculate XP required for a specific level\n * @param {number} level - Target level\n * @returns {number} XP required\n */\nfunction getXpForLevel(level) {\n    return config.levelSystem.xpPerLevel(level);\n}\n\n/**\n * Get rank information for a given level\n * @param {number} level - User level\n * @returns {object} Rank information\n */\nfunction getRankByLevel(level) {\n    const ranks = config.levelSystem.ranks;\n    for (const rank of ranks) {\n        if (level >= rank.minLevel && level <= rank.maxLevel) {\n            return rank;\n        }\n    }\n    return ranks[ranks.length - 1]; // Return highest rank if level exceeds all\n}\n\n/**\n * Get the next rank for a given level\n * @param {number} level - Current level\n * @returns {object|null} Next rank information or null if at max rank\n */\nfunction getNextRank(level) {\n    const currentRank = getRankByLevel(level);\n    const ranks = config.levelSystem.ranks;\n    const currentRankIndex = ranks.findIndex(rank => rank.name === currentRank.name);\n    \n    if (currentRankIndex < ranks.length - 1) {\n        return ranks[currentRankIndex + 1];\n    }\n    return null; // Already at highest rank\n}\n\n/**\n * Calculate XP progress for current level\n * @param {number} currentXp - Current XP\n * @param {number} level - Current level\n * @returns {object} Progress information\n */\nfunction getXpProgress(currentXp, level) {\n    const requiredXp = getXpForLevel(level);\n    const percentage = Math.floor((currentXp / requiredXp) * 100);\n    \n    return {\n        current: currentXp,\n        required: requiredXp,\n        percentage: Math.min(percentage, 100),\n        remaining: Math.max(requiredXp - currentXp, 0)\n    };\n}\n\n/**\n * Get all available ranks\n * @returns {array} All ranks configuration\n */\nfunction getAllRanks() {\n    return config.levelSystem.ranks;\n}\n\n/**\n * Award XP to user for specific actions\n * @param {string} action - Action type (commandUse, dailyLogin, etc.)\n * @returns {number} XP amount\n */\nfunction getXpReward(action) {\n    return config.levelSystem.rewards[action] || 0;\n}\n\nmodule.exports = {\n    getXpForLevel,\n    getRankByLevel,\n    getNextRank,\n    getXpProgress,\n    getAllRanks,\n    getXpReward\n};","size_bytes":2223},"utils/messageUtils.js":{"content":"const config = require('../config/config');\n\n/**\n * Extract command and arguments from message text\n * @param {string} messageText - The message text\n * @returns {Object} Command and arguments\n */\nconst parseCommand = (messageText) => {\n    if (!messageText || !messageText.startsWith(config.commands.prefix)) {\n        return { command: null, args: [] };\n    }\n    \n    const parts = messageText.slice(config.commands.prefix.length).trim().split(' ');\n    const command = parts[0].toLowerCase();\n    const args = parts.slice(1);\n    \n    return { command, args };\n};\n\n/**\n * Check if message is a command\n * @param {string} messageText - The message text\n * @returns {boolean} Is command status\n */\nconst isCommand = (messageText) => {\n    return messageText && messageText.startsWith(config.commands.prefix);\n};\n\n/**\n * Format user mention\n * @param {string} userId - WhatsApp user ID\n * @returns {string} Formatted mention\n */\nconst formatMention = (userId) => {\n    const phoneNumber = userId.split('@')[0];\n    return `@${phoneNumber}`;\n};\n\n/**\n * Extract phone number from user ID\n * @param {string} userId - WhatsApp user ID\n * @returns {string} Phone number\n */\nconst extractPhoneNumber = (userId) => {\n    return userId.split('@')[0];\n};\n\n/**\n * Format currency display\n * @param {number} amount - Amount to format\n * @param {string} currency - Currency type (balance, chips)\n * @returns {string} Formatted currency\n */\nconst formatCurrency = (amount, currency = 'balance') => {\n    const symbols = {\n        balance: 'üí∞',\n        chips: 'üéØ'\n    };\n    \n    return `${symbols[currency] || 'üí∞'} ${amount.toLocaleString()}`;\n};\n\n/**\n * Format time ago\n * @param {Date} date - Date to format\n * @returns {string} Time ago string\n */\nconst formatTimeAgo = (date) => {\n    const now = new Date();\n    const diffInSeconds = Math.floor((now - date) / 1000);\n    \n    if (diffInSeconds < 60) {\n        return `${diffInSeconds} seconds ago`;\n    } else if (diffInSeconds < 3600) {\n        const minutes = Math.floor(diffInSeconds / 60);\n        return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;\n    } else if (diffInSeconds < 86400) {\n        const hours = Math.floor(diffInSeconds / 3600);\n        return `${hours} hour${hours > 1 ? 's' : ''} ago`;\n    } else {\n        const days = Math.floor(diffInSeconds / 86400);\n        return `${days} day${days > 1 ? 's' : ''} ago`;\n    }\n};\n\n/**\n * Clean and validate message text\n * @param {string} text - Text to clean\n * @returns {string} Cleaned text\n */\nconst cleanMessageText = (text) => {\n    if (!text) return '';\n    \n    return text\n        .trim()\n        .replace(/\\n+/g, '\\n') // Remove excessive newlines\n        .replace(/\\s+/g, ' ') // Remove excessive spaces\n        .substring(0, 1000); // Limit length\n};\n\n/**\n * Create error message\n * @param {string} error - Error message\n * @param {string} command - Command that caused error\n * @returns {string} Formatted error message\n */\nconst createErrorMessage = (error, command = '') => {\n    return `‚ùå Error${command ? ` in command .${command}` : ''}: ${error}`;\n};\n\n/**\n * Create success message\n * @param {string} message - Success message\n * @param {string} command - Command that succeeded\n * @returns {string} Formatted success message\n */\nconst createSuccessMessage = (message, command = '') => {\n    return `‚úÖ${command ? ` .${command}` : ''}: ${message}`;\n};\n\n/**\n * Validate WhatsApp user ID format\n * @param {string} userId - User ID to validate\n * @returns {boolean} Is valid format\n */\nconst isValidUserId = (userId) => {\n    if (!userId || typeof userId !== 'string') return false;\n    \n    // Check for valid WhatsApp ID format\n    const whatsappIdPattern = /^\\d+@(s\\.whatsapp\\.net|g\\.us)$/;\n    return whatsappIdPattern.test(userId);\n};\n\n/**\n * Generate random ID\n * @param {number} length - Length of ID\n * @returns {string} Random ID\n */\nconst generateRandomId = (length = 8) => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n};\n\nmodule.exports = {\n    parseCommand,\n    isCommand,\n    formatMention,\n    extractPhoneNumber,\n    formatCurrency,\n    formatTimeAgo,\n    cleanMessageText,\n    createErrorMessage,\n    createSuccessMessage,\n    isValidUserId,\n    generateRandomId\n};\n","size_bytes":4420},"utils/stickerUtils.js":{"content":"const sharp = require('sharp');\nconst { downloadMediaMessage } = require('@whiskeysockets/baileys');\nconst fs = require('fs');\nconst path = require('path');\nconst config = require('../config/config');\nconst { Sticker, StickerTypes } = require('wa-sticker-formatter');\n\n// Convert image to sticker using wa-sticker-formatter\nconst createSticker = async (buffer, pack = config.sticker.pack, author = config.sticker.author) => {\n    try {\n        console.log(`üé® Creating sticker with pack: ${pack}, author: ${author}`);\n        \n        // Create sticker using wa-sticker-formatter with proper metadata\n        const sticker = new Sticker(buffer, {\n            pack: pack,\n            author: author,\n            type: StickerTypes.FULL,\n            quality: 75,\n            categories: ['ü§ñ', 'üí¨'],\n            id: `seana-bot-${Date.now()}`,\n            background: 'transparent'\n        });\n\n        // Convert to WebP buffer with metadata\n        const stickerBuffer = await sticker.toBuffer();\n        \n        console.log(`‚úÖ Sticker created with metadata - Pack: ${pack}, Author: ${author}`);\n        return stickerBuffer;\n        \n    } catch (error) {\n        console.error('‚ùå Error creating sticker with wa-sticker-formatter:', error.message);\n        \n        // Fallback: create basic sticker without metadata\n        try {\n            console.log('üîÑ Trying fallback method...');\n            \n            // Create temp directory if it doesn't exist\n            const tempDir = path.join(__dirname, '../temp');\n            if (!fs.existsSync(tempDir)) {\n                fs.mkdirSync(tempDir, { recursive: true });\n            }\n\n            const tempInputPath = path.join(tempDir, `input_${Date.now()}.png`);\n\n            // Process image with sharp - resize and convert to PNG\n            await sharp(buffer)\n                .resize(512, 512, {\n                    fit: 'contain',\n                    background: { r: 0, g: 0, b: 0, alpha: 0 }\n                })\n                .webp({ quality: 75 })\n                .toFile(tempInputPath);\n\n            const stickerBuffer = fs.readFileSync(tempInputPath);\n            \n            // Clean up temp file\n            try {\n                fs.unlinkSync(tempInputPath);\n            } catch (cleanupError) {\n                console.log('‚ö†Ô∏è Could not clean up temp file:', cleanupError.message);\n            }\n\n            console.log('‚úÖ Created basic sticker without metadata');\n            return stickerBuffer;\n            \n        } catch (fallbackError) {\n            console.error('‚ùå Fallback sticker creation failed:', fallbackError.message);\n            throw new Error('Failed to create sticker. Please make sure the image is valid.');\n        }\n    }\n};\n\n// Download media from WhatsApp message\nconst downloadMedia = async (message) => {\n    try {\n        const buffer = await downloadMediaMessage(\n            message,\n            'buffer',\n            {},\n            {\n                logger: console,\n                reuploadRequest: () => Promise.resolve()\n            }\n        );\n        return buffer;\n    } catch (error) {\n        console.error('‚ùå Error downloading media:', error.message);\n        throw new Error('Failed to download media from message.');\n    }\n};\n\n// Check if message contains image\nconst isImageMessage = (message) => {\n    return !!(\n        message.message?.imageMessage ||\n        message.message?.viewOnceMessage?.message?.imageMessage ||\n        message.message?.ephemeralMessage?.message?.imageMessage\n    );\n};\n\n// Get image message from different types\nconst getImageMessage = (message) => {\n    if (message.message?.imageMessage) {\n        return message.message.imageMessage;\n    }\n    if (message.message?.viewOnceMessage?.message?.imageMessage) {\n        return message.message.viewOnceMessage.message.imageMessage;\n    }\n    if (message.message?.ephemeralMessage?.message?.imageMessage) {\n        return message.message.ephemeralMessage.message.imageMessage;\n    }\n    return null;\n};\n\nmodule.exports = {\n    createSticker,\n    downloadMedia,\n    isImageMessage,\n    getImageMessage\n};","size_bytes":4120},"utils/userUtils.js":{"content":"const User = require('../database/models/User');\nconst config = require('../config/config');\n\n/**\n * Get user from database\n * @param {string} userId - WhatsApp user ID\n * @returns {Object|null} User object or null\n */\nconst getUser = async (userId) => {\n    try {\n        const user = await User.findByUserId(userId);\n        return user;\n    } catch (error) {\n        console.error('‚ùå Error getting user:', error.message);\n        return null;\n    }\n};\n\n/**\n * Create new user if doesn't exist\n * @param {string} userId - WhatsApp user ID\n * @param {Object} additionalData - Additional user data\n * @param {Object} sock - WhatsApp socket for fetching profile data\n * @returns {Object|null} User object or null\n */\nconst createUser = async (userId, additionalData = {}, sock = null) => {\n    try {\n        // Check if user already exists\n        let user = await User.findByUserId(userId);\n        \n        if (!user) {\n            // Extract phone number from userId\n            const phoneNumber = userId.split('@')[0];\n            \n            // Try to get WhatsApp name if socket is provided\n            let whatsappName = `User${phoneNumber.slice(-4)}`;\n            if (sock) {\n                try {\n                    const contactInfo = await sock.onWhatsApp(userId);\n                    if (contactInfo && contactInfo[0] && contactInfo[0].notify) {\n                        whatsappName = contactInfo[0].notify;\n                    }\n                } catch (error) {\n                    console.log('Could not fetch WhatsApp name during user creation');\n                }\n            }\n            \n            // Set special permissions for owner\n            const isOwner = phoneNumber === config.ownerNumber.split('@')[0];\n            const userData = {\n                phoneNumber,\n                username: additionalData.username || whatsappName,\n                status: isOwner ? 'owner' : config.defaultSettings.status,\n                ...additionalData\n            };\n            \n            user = await User.createNewUser(userId, userData);\n            console.log(`üë§ New user created: ${userId} (${user.status})`);\n        }\n        \n        return user;\n    } catch (error) {\n        console.error('‚ùå Error creating user:', error.message);\n        return null;\n    }\n};\n\n/**\n * Update user data\n * @param {string} userId - WhatsApp user ID\n * @param {Object} updateData - Data to update\n * @returns {Object|null} Updated user or null\n */\nconst updateUser = async (userId, updateData) => {\n    try {\n        const user = await User.findOneAndUpdate(\n            { userId },\n            { $set: updateData },\n            { new: true, runValidators: true }\n        );\n        \n        if (user) {\n            console.log(`üìù User updated: ${userId}`);\n        }\n        \n        return user;\n    } catch (error) {\n        console.error('‚ùå Error updating user:', error.message);\n        return null;\n    }\n};\n\n/**\n * Add limit to user\n * @param {string} userId - WhatsApp user ID\n * @param {number} amount - Amount to add\n * @returns {boolean} Success status\n */\nconst addUserLimit = async (userId, amount = 1) => {\n    try {\n        const user = await User.findByUserId(userId);\n        if (!user) return false;\n        \n        user.addLimit(amount);\n        await user.save();\n        \n        console.log(`‚ûï Added ${amount} limit(s) to user: ${userId}`);\n        return true;\n    } catch (error) {\n        console.error('‚ùå Error adding user limit:', error.message);\n        return false;\n    }\n};\n\n/**\n * Deduct limit from user\n * @param {string} userId - WhatsApp user ID\n * @param {number} amount - Amount to deduct\n * @returns {boolean} Success status\n */\nconst deductUserLimit = async (userId, amount = 1) => {\n    try {\n        const user = await User.findByUserId(userId);\n        if (!user) return false;\n        \n        const success = user.deductLimit(amount);\n        if (success) {\n            await user.save();\n            console.log(`‚ûñ Deducted ${amount} limit(s) from user: ${userId}`);\n        }\n        \n        return success;\n    } catch (error) {\n        console.error('‚ùå Error deducting user limit:', error.message);\n        return false;\n    }\n};\n\n/**\n * Check if user is owner\n * @param {string} userId - WhatsApp user ID\n * @returns {boolean} Is owner status\n */\nconst isUserOwner = async (userId) => {\n    try {\n        const user = await User.findByUserId(userId);\n        return user ? user.isOwner() : false;\n    } catch (error) {\n        console.error('‚ùå Error checking owner status:', error.message);\n        return false;\n    }\n};\n\n/**\n * Check if user is admin or owner\n * @param {string} userId - WhatsApp user ID\n * @returns {boolean} Is admin status\n */\nconst isUserAdmin = async (userId) => {\n    try {\n        const user = await User.findByUserId(userId);\n        return user ? user.isAdmin() : false;\n    } catch (error) {\n        console.error('‚ùå Error checking admin status:', error.message);\n        return false;\n    }\n};\n\n/**\n * Add XP to user and handle level up\n * @param {string} userId - WhatsApp user ID\n * @param {number} amount - XP amount to add\n * @returns {Object|null} Level up info or null\n */\nconst addUserXp = async (userId, amount = 10) => {\n    try {\n        const user = await User.findByUserId(userId);\n        if (!user) return null;\n        \n        const oldLevel = user.level;\n        user.addXp(amount);\n        await user.save();\n        \n        // Check if user leveled up\n        if (user.level > oldLevel) {\n            console.log(`üÜô User ${userId} leveled up! ${oldLevel} ‚Üí ${user.level}`);\n            return {\n                leveledUp: true,\n                oldLevel,\n                newLevel: user.level,\n                currentRank: user.getCurrentRank()\n            };\n        }\n        \n        return { leveledUp: false };\n    } catch (error) {\n        console.error('‚ùå Error adding XP:', error.message);\n        return null;\n    }\n};\n\n/**\n * Update user activity and award XP\n * @param {string} userId - WhatsApp user ID\n * @param {string} action - Action type (commandUse, dailyLogin, etc.)\n * @returns {Object|null} Activity update result\n */\nconst updateUserActivity = async (userId, action = 'commandUse') => {\n    try {\n        const user = await User.findByUserId(userId);\n        if (!user) return null;\n        \n        const oldLevel = user.level;\n        \n        // Update activity\n        user.lastActive = new Date();\n        user.commandsUsed += 1;\n        \n        // Award XP based on action\n        const xpReward = config.levelSystem.rewards[action] || 10;\n        user.addXp(xpReward);\n        \n        await user.save();\n        \n        // Check if user leveled up\n        if (user.level > oldLevel) {\n            console.log(`üÜô User ${userId} leveled up! ${oldLevel} ‚Üí ${user.level}`);\n            return {\n                leveledUp: true,\n                oldLevel,\n                newLevel: user.level,\n                currentRank: user.getCurrentRank(),\n                xpGained: xpReward\n            };\n        }\n        \n        return { \n            leveledUp: false, \n            xpGained: xpReward \n        };\n    } catch (error) {\n        console.error('‚ùå Error updating user activity:', error.message);\n        return null;\n    }\n};\n\n/**\n * Get user statistics\n * @returns {Object} User statistics\n */\nconst getUserStats = async () => {\n    try {\n        const totalUsers = await User.countDocuments();\n        const activeUsers = await User.countDocuments({\n            lastActive: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }\n        });\n        const ownerCount = await User.countDocuments({ status: 'owner' });\n        const adminCount = await User.countDocuments({ status: 'admin' });\n        const basicCount = await User.countDocuments({ status: 'basic' });\n        \n        return {\n            totalUsers,\n            activeUsers,\n            ownerCount,\n            adminCount,\n            basicCount\n        };\n    } catch (error) {\n        console.error('‚ùå Error getting user stats:', error.message);\n        return null;\n    }\n};\n\nmodule.exports = {\n    getUser,\n    createUser,\n    updateUser,\n    addUserLimit,\n    deductUserLimit,\n    isUserOwner,\n    isUserAdmin,\n    getUserStats,\n    addUserXp,\n    updateUserActivity\n};\n","size_bytes":8327},"database/models/Announcement.js":{"content":"const mongoose = require('mongoose');\n\nconst announcementSchema = new mongoose.Schema({\n    title: {\n        type: String,\n        required: true,\n        maxlength: 255\n    },\n    content: {\n        type: String,\n        required: true\n    },\n    author: {\n        type: String,\n        required: true,\n        maxlength: 100\n    },\n    icon: {\n        type: String,\n        default: 'üì¢',\n        maxlength: 50\n    },\n    category: {\n        type: String,\n        default: 'pengumuman',\n        enum: ['pengumuman', 'event', 'update', 'maintenance']\n    },\n    isActive: {\n        type: Boolean,\n        default: true\n    }\n}, {\n    timestamps: true // This adds createdAt and updatedAt automatically\n});\n\n// Index for better query performance\nannouncementSchema.index({ createdAt: -1 });\nannouncementSchema.index({ isActive: 1 });\n\nmodule.exports = mongoose.model('Announcement', announcementSchema);","size_bytes":905},"database/models/Post.js":{"content":"\nconst mongoose = require('mongoose');\n\nconst postSchema = new mongoose.Schema({\n    // User Information\n    userId: {\n        type: String,\n        required: true,\n        index: true\n    },\n    \n    author: {\n        type: String,\n        required: true\n    },\n    \n    // Post Content\n    type: {\n        type: String,\n        enum: ['text', 'image', 'video'],\n        default: 'text'\n    },\n    \n    content: {\n        type: String,\n        required: true\n    },\n    \n    mediaUrl: {\n        type: String,\n        default: ''\n    },\n    \n    // Engagement\n    likes: [{\n        userId: String,\n        timestamp: {\n            type: Date,\n            default: Date.now\n        }\n    }],\n    \n    comments: [{\n        userId: String,\n        author: String,\n        content: String,\n        timestamp: {\n            type: Date,\n            default: Date.now\n        }\n    }],\n    \n    // Timestamps\n    createdAt: {\n        type: Date,\n        default: Date.now\n    }\n}, {\n    timestamps: true,\n    versionKey: false\n});\n\n// Indexes for better performance\npostSchema.index({ createdAt: -1 });\npostSchema.index({ userId: 1, createdAt: -1 });\n\n// Methods\npostSchema.methods.getLikesCount = function() {\n    return this.likes.length;\n};\n\npostSchema.methods.getCommentsCount = function() {\n    return this.comments.length;\n};\n\npostSchema.methods.isLikedBy = function(userId) {\n    return this.likes.some(like => like.userId === userId);\n};\n\npostSchema.methods.addLike = function(userId) {\n    if (!this.isLikedBy(userId)) {\n        this.likes.push({ userId });\n        return true;\n    }\n    return false;\n};\n\npostSchema.methods.removeLike = function(userId) {\n    const initialLength = this.likes.length;\n    this.likes = this.likes.filter(like => like.userId !== userId);\n    return this.likes.length < initialLength;\n};\n\npostSchema.methods.addComment = function(userId, author, content) {\n    this.comments.push({ userId, author, content });\n};\n\n// Static methods\npostSchema.statics.getRecentPosts = function(limit = 20) {\n    return this.find()\n        .sort({ createdAt: -1 })\n        .limit(limit);\n};\n\npostSchema.statics.getPostsByUser = function(userId, limit = 20) {\n    return this.find({ userId })\n        .sort({ createdAt: -1 })\n        .limit(limit);\n};\n\nmodule.exports = mongoose.model('Post', postSchema);\n","size_bytes":2321},"database/models/User.js":{"content":"const mongoose = require('mongoose');\nconst config = require('../../config/config');\n\nconst userSchema = new mongoose.Schema({\n    // WhatsApp User ID\n    userId: {\n        type: String,\n        required: true,\n        unique: true,\n        index: true\n    },\n    \n    // User Information\n    username: {\n        type: String,\n        default: 'User'\n    },\n    \n    phoneNumber: {\n        type: String,\n        default: ''\n    },\n    \n    profilePhoto: {\n        type: String,\n        default: null\n    },\n    \n    // User Status and Permissions\n    status: {\n        type: String,\n        enum: ['owner', 'premium', 'basic'],\n        default: config.defaultSettings.status\n    },\n    \n    // User Resources\n    limit: {\n        type: Number,\n        default: config.defaultSettings.limit,\n        min: 0\n    },\n    \n    totalLimit: {\n        type: Number,\n        default: config.defaultSettings.limit\n    },\n    \n    balance: {\n        type: Number,\n        default: config.defaultSettings.balance,\n        min: 0\n    },\n    \n    chips: {\n        type: Number,\n        default: config.defaultSettings.chips,\n        min: 0\n    },\n    \n    // Activity Tracking\n    lastActive: {\n        type: Date,\n        default: Date.now\n    },\n    \n    commandsUsed: {\n        type: Number,\n        default: 0\n    },\n    \n    // Level System\n    level: {\n        type: Number,\n        default: 1,\n        min: 1\n    },\n    \n    xp: {\n        type: Number,\n        default: 0,\n        min: 0\n    },\n    \n    totalXp: {\n        type: Number,\n        default: 0,\n        min: 0\n    },\n    \n    // Profile customization\n    profilePicture: {\n        type: String,\n        default: null\n    },\n    \n    // Timestamps\n    memberSince: {\n        type: Date,\n        default: Date.now\n    }\n}, {\n    timestamps: true,\n    versionKey: false\n});\n\n// Indexes for better performance (userId already has unique index from schema definition)\nuserSchema.index({ status: 1 });\nuserSchema.index({ lastActive: -1 });\n\n// Methods\nuserSchema.methods.deductLimit = function(amount = 1) {\n    // Owner and premium users have unlimited limits\n    if (this.status === 'owner' || this.status === 'premium') {\n        return true;\n    }\n    \n    if (this.limit >= amount) {\n        this.limit -= amount;\n        return true;\n    }\n    return false;\n};\n\nuserSchema.methods.hasUnlimitedLimits = function() {\n    return this.status === 'owner' || this.status === 'premium';\n};\n\nuserSchema.methods.addLimit = function(amount = 1) {\n    this.limit += amount;\n    if (this.limit > this.totalLimit) {\n        this.limit = this.totalLimit;\n    }\n};\n\nuserSchema.methods.updateActivity = function() {\n    this.lastActive = new Date();\n    this.commandsUsed += 1;\n};\n\nuserSchema.methods.isOwner = function() {\n    return this.status === 'owner';\n};\n\nuserSchema.methods.isAdmin = function() {\n    return this.status === 'admin' || this.status === 'owner';\n};\n\nuserSchema.methods.getFormattedMemberSince = function() {\n    return this.memberSince.toLocaleDateString('id-ID', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n    });\n};\n\n// Level System Methods\nuserSchema.methods.addXp = function(amount) {\n    this.xp += amount;\n    this.totalXp += amount;\n    \n    // Check for level up\n    const xpRequired = config.levelSystem.xpPerLevel(this.level);\n    if (this.xp >= xpRequired) {\n        this.levelUp();\n    }\n};\n\nuserSchema.methods.levelUp = function() {\n    const xpRequired = config.levelSystem.xpPerLevel(this.level);\n    this.xp -= xpRequired;\n    this.level += 1;\n    \n    // Check if enough XP for multiple level ups\n    const nextXpRequired = config.levelSystem.xpPerLevel(this.level);\n    if (this.xp >= nextXpRequired) {\n        this.levelUp(); // Recursive level up\n    }\n};\n\nuserSchema.methods.getCurrentRank = function() {\n    const ranks = config.levelSystem.ranks;\n    for (const rank of ranks) {\n        if (this.level >= rank.minLevel && this.level <= rank.maxLevel) {\n            return rank;\n        }\n    }\n    return ranks[ranks.length - 1]; // Return highest rank if level exceeds all\n};\n\nuserSchema.methods.getXpProgress = function() {\n    const currentLevelXp = config.levelSystem.xpPerLevel(this.level);\n    const progressPercentage = Math.floor((this.xp / currentLevelXp) * 100);\n    return {\n        current: this.xp,\n        required: currentLevelXp,\n        percentage: Math.min(progressPercentage, 100)\n    };\n};\n\nuserSchema.methods.getNextRank = function() {\n    const currentRank = this.getCurrentRank();\n    const ranks = config.levelSystem.ranks;\n    const currentRankIndex = ranks.findIndex(rank => rank.name === currentRank.name);\n    \n    if (currentRankIndex < ranks.length - 1) {\n        return ranks[currentRankIndex + 1];\n    }\n    return null; // Already at highest rank\n};\n\n// Static methods\nuserSchema.statics.findByUserId = function(userId) {\n    return this.findOne({ userId });\n};\n\nuserSchema.statics.createNewUser = async function(userId, additionalData = {}) {\n    const userData = {\n        userId,\n        ...additionalData\n    };\n    \n    const user = new this(userData);\n    return await user.save();\n};\n\nmodule.exports = mongoose.model('User', userSchema);\n","size_bytes":5193}}}